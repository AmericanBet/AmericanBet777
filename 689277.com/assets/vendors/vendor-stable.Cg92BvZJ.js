import {
    c as Ka,
    a as wu
} from "./vendor-bignumber.BRr1dcww.js";
import {
    B as Eu,
    q as Ru,
    C as Ou,
    D as Su,
    E as ku,
    v as Pu,
    x as xu,
    F as Go,
    K as Tu,
    R as Cu,
    S as Au,
    y as Iu,
    T as Nu,
    z as Us,
    A as Lu,
    G as Fu,
    H as Du,
    I as Mu,
    V as ju,
    J as Bu,
    L as Ku,
    M as Uu,
    N as qu,
    O as Vu,
    P as Hu,
    Q as $u,
    c as Ce,
    U as Wu,
    W as zu,
    X as Gu,
    Y as Yu,
    Z as Ju,
    _ as Xu,
    $ as Qu,
    a0 as Zu,
    a1 as ec,
    a2 as tc,
    a3 as nc,
    a4 as rc,
    a5 as qs,
    a6 as oc,
    a7 as ac,
    k as _n,
    a8 as sc,
    a9 as ic,
    aa as uc,
    ab as cc,
    ac as lc,
    ad as fc,
    ae as dc,
    af as hc,
    ag as pc,
    ah as mc,
    ai as xr,
    g as pn,
    aj as Vs,
    ak as yc,
    al as gc,
    l as $n,
    am as vc,
    an as Hs,
    ao as bc,
    ap as _c,
    aq as wc,
    i as gt,
    ar as Ec,
    as as Rc,
    at as Tr,
    au as Oc,
    a as en,
    av as Sc,
    aw as kc,
    ax as Pc,
    ay as Yo,
    az as xc,
    aA as Tc,
    aB as Cc,
    n as Jo,
    aC as Ac,
    aD as Ic,
    aE as Nc,
    aF as $s,
    aG as Ws,
    b as Lc,
    aH as Fc,
    aI as zs,
    aJ as Dc,
    o as Gs,
    aK as Mc,
    aL as jc,
    j as Ys,
    aM as Bc,
    aN as Xo,
    m as Kc,
    aO as Uc,
    aP as qc,
    p as _r,
    aQ as Vc,
    aR as Hc,
    aS as $c,
    d as Qo,
    e as Wc,
    r as St,
    aT as zc,
    aU as Gc,
    aV as Yc,
    aW as Jc,
    aX as Xc,
    aY as Qc,
    aZ as Zc,
    a_ as el,
    a$ as tl,
    b0 as nl,
    b1 as rl,
    b2 as ol,
    b3 as Js,
    b4 as al,
    s as Cr,
    b5 as sl,
    b6 as il,
    b7 as ul,
    b8 as cl,
    b9 as ll,
    ba as fl,
    bb as Zo,
    bc as Xs,
    bd as Qs,
    t as dl,
    be as hl,
    h as pl,
    u as hn,
    bf as ml,
    bg as yl,
    bh as gl,
    bi as vl,
    bj as bl,
    bk as _l,
    bl as wl,
    bm as El,
    bn as Rl,
    bo as Ol,
    bp as Sl,
    bq as kl,
    br as Pl,
    bs as xl,
    bt as Tl,
    w as mn,
    f as Cl,
    bu as Al,
    bv as Il,
    bw as Nl,
    bx as Ll,
    by as Fl,
    bz as Dl,
    bA as Ml,
    bB as jl,
    bC as Bl,
    bD as Kl
} from "./vendor-@vue.CBvhRkQp.js";
import {
    a as mt,
    i as yn,
    b as Ee,
    c as pt,
    d as Te,
    e as Ul,
    D as ea,
    f as tt,
    g as Le,
    h as gn,
    j as Vt,
    r as Ua,
    k as ql,
    l as Vl,
    m as fn,
    s as Hl,
    n as $l,
    o as Ht,
    p as wr,
    q as Or,
    u as Fn,
    t as Sr,
    N as Wl,
    v as zl,
    w as Gl,
    x as Yl,
    y as Jl,
    z as Zs,
    C as Xl,
    A as ei,
    B as Ql,
    E as qa,
    F as Va,
    G as Zl,
    H as ef,
    I as tf,
    J as Ha,
    K as $a,
    M as Wa,
    L as za,
    O as Ga,
    P as Ya,
    Q as Ja,
    R as nf,
    S as rf,
    T as of ,
    U as Xa
} from "./vendor-@intlify.BmUtFfVu.js";
import {
    i as af
} from "./vendor-default.p-wnugzB.js";
var ti = {
    exports: {}
};
(function(t, r) {
    (function(o, a) {
        t.exports = a()
    })(Ka, function() {
        var o = function(e, n) {
                return (o = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(s, u) {
                        s.__proto__ = u
                    } || function(s, u) {
                        for (var l in u) Object.prototype.hasOwnProperty.call(u, l) && (s[l] = u[l])
                    })(e, n)
            },
            a = function() {
                return (a = Object.assign || function(e) {
                    for (var n, s = 1, u = arguments.length; s < u; s++)
                        for (var l in n = arguments[s]) Object.prototype.hasOwnProperty.call(n, l) && (e[l] = n[l]);
                    return e
                }).apply(this, arguments)
            };

        function c(e, n, s) {
            for (var u, l = 0, d = n.length; l < d; l++) !u && l in n || ((u = u || Array.prototype.slice.call(n, 0, l))[l] = n[l]);
            return e.concat(u || Array.prototype.slice.call(n))
        }
        var i = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Ka,
            f = Object.keys,
            p = Array.isArray;

        function m(e, n) {
            return typeof n != "object" || f(n).forEach(function(s) {
                e[s] = n[s]
            }), e
        }
        typeof Promise > "u" || i.Promise || (i.Promise = Promise);
        var v = Object.getPrototypeOf,
            g = {}.hasOwnProperty;

        function _(e, n) {
            return g.call(e, n)
        }

        function T(e, n) {
            typeof n == "function" && (n = n(v(e))), (typeof Reflect > "u" ? f : Reflect.ownKeys)(n).forEach(function(s) {
                B(e, s, n[s])
            })
        }
        var A = Object.defineProperty;

        function B(e, n, s, u) {
            A(e, n, m(s && _(s, "get") && typeof s.get == "function" ? {
                get: s.get,
                set: s.set,
                configurable: !0
            } : {
                value: s,
                configurable: !0,
                writable: !0
            }, u))
        }

        function q(e) {
            return {
                from: function(n) {
                    return e.prototype = Object.create(n.prototype), B(e.prototype, "constructor", e), {
                        extend: T.bind(null, e.prototype)
                    }
                }
            }
        }
        var re = Object.getOwnPropertyDescriptor,
            oe = [].slice;

        function te(e, n, s) {
            return oe.call(e, n, s)
        }

        function Q(e, n) {
            return n(e)
        }

        function ye(e) {
            if (!e) throw new Error("Assertion Failed")
        }

        function _e(e) {
            i.setImmediate ? setImmediate(e) : setTimeout(e, 0)
        }

        function me(e, n) {
            if (typeof n == "string" && _(e, n)) return e[n];
            if (!n) return e;
            if (typeof n != "string") {
                for (var s = [], u = 0, l = n.length; u < l; ++u) {
                    var d = me(e, n[u]);
                    s.push(d)
                }
                return s
            }
            var h = n.indexOf(".");
            if (h !== -1) {
                var y = e[n.substr(0, h)];
                return y == null ? void 0 : me(y, n.substr(h + 1))
            }
        }

        function se(e, n, s) {
            if (e && n !== void 0 && !("isFrozen" in Object && Object.isFrozen(e)))
                if (typeof n != "string" && "length" in n) {
                    ye(typeof s != "string" && "length" in s);
                    for (var u = 0, l = n.length; u < l; ++u) se(e, n[u], s[u])
                } else {
                    var d, h, y = n.indexOf(".");
                    y !== -1 ? (d = n.substr(0, y), (h = n.substr(y + 1)) === "" ? s === void 0 ? p(e) && !isNaN(parseInt(d)) ? e.splice(d, 1) : delete e[d] : e[d] = s : se(y = !(y = e[d]) || !_(e, d) ? e[d] = {} : y, h, s)) : s === void 0 ? p(e) && !isNaN(parseInt(n)) ? e.splice(n, 1) : delete e[n] : e[n] = s
                }
        }

        function fe(e) {
            var n, s = {};
            for (n in e) _(e, n) && (s[n] = e[n]);
            return s
        }
        var z = [].concat;

        function Ae(e) {
            return z.apply([], e)
        }
        var Tt = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Ae([8, 16, 32, 64].map(function(e) {
                return ["Int", "Uint", "Float"].map(function(n) {
                    return n + e + "Array"
                })
            }))).filter(function(e) {
                return i[e]
            }),
            Ve = new Set(Tt.map(function(e) {
                return i[e]
            })),
            je = null;

        function Fe(e) {
            return je = new WeakMap, e = function n(s) {
                if (!s || typeof s != "object") return s;
                var u = je.get(s);
                if (u) return u;
                if (p(s)) {
                    u = [], je.set(s, u);
                    for (var l = 0, d = s.length; l < d; ++l) u.push(n(s[l]))
                } else if (Ve.has(s.constructor)) u = s;
                else {
                    var h, y = v(s);
                    for (h in u = y === Object.prototype ? {} : Object.create(y), je.set(s, u), s) _(s, h) && (u[h] = n(s[h]))
                }
                return u
            }(e), je = null, e
        }
        var kt = {}.toString;

        function He(e) {
            return kt.call(e).slice(8, -1)
        }
        var Oe = typeof Symbol < "u" ? Symbol.iterator : "@@iterator",
            _t = typeof Oe == "symbol" ? function(e) {
                var n;
                return e != null && (n = e[Oe]) && n.apply(e)
            } : function() {
                return null
            };

        function Xe(e, n) {
            return n = e.indexOf(n), 0 <= n && e.splice(n, 1), 0 <= n
        }
        var at = {};

        function $e(e) {
            var n, s, u, l;
            if (arguments.length === 1) {
                if (p(e)) return e.slice();
                if (this === at && typeof e == "string") return [e];
                if (l = _t(e)) {
                    for (s = []; !(u = l.next()).done;) s.push(u.value);
                    return s
                }
                if (e == null) return [e];
                if (typeof(n = e.length) != "number") return [e];
                for (s = new Array(n); n--;) s[n] = e[n];
                return s
            }
            for (n = arguments.length, s = new Array(n); n--;) s[n] = arguments[n];
            return s
        }
        var ze = typeof Symbol < "u" ? function(e) {
                return e[Symbol.toStringTag] === "AsyncFunction"
            } : function() {
                return !1
            },
            Pe = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"],
            ut = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Pe),
            wt = {
                VersionChanged: "Database version changed by other database connection",
                DatabaseClosed: "Database has been closed",
                Abort: "Transaction aborted",
                TransactionInactive: "Transaction has already completed or failed",
                MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
            };

        function Ze(e, n) {
            this.name = e, this.message = n
        }

        function lt(e, n) {
            return e + ". Errors: " + Object.keys(n).map(function(s) {
                return n[s].toString()
            }).filter(function(s, u, l) {
                return l.indexOf(s) === u
            }).join("\n")
        }

        function ft(e, n, s, u) {
            this.failures = n, this.failedKeys = u, this.successCount = s, this.message = lt(e, n)
        }

        function We(e, n) {
            this.name = "BulkError", this.failures = Object.keys(n).map(function(s) {
                return n[s]
            }), this.failuresByPos = n, this.message = lt(e, this.failures)
        }
        q(Ze).from(Error).extend({
            toString: function() {
                return this.name + ": " + this.message
            }
        }), q(ft).from(Ze), q(We).from(Ze);
        var K = ut.reduce(function(e, n) {
                return e[n] = n + "Error", e
            }, {}),
            X = Ze,
            F = ut.reduce(function(e, n) {
                var s = n + "Error";

                function u(l, d) {
                    this.name = s, l ? typeof l == "string" ? (this.message = "".concat(l).concat(d ? "\n " + d : ""), this.inner = d || null) : typeof l == "object" && (this.message = "".concat(l.name, " ").concat(l.message), this.inner = l) : (this.message = wt[n] || s, this.inner = null)
                }
                return q(u).from(X), e[n] = u, e
            }, {});
        F.Syntax = SyntaxError, F.Type = TypeError, F.Range = RangeError;
        var Z = Pe.reduce(function(e, n) {
                return e[n + "Error"] = F[n], e
            }, {}),
            ge = ut.reduce(function(e, n) {
                return ["Syntax", "Type", "Range"].indexOf(n) === -1 && (e[n + "Error"] = F[n]), e
            }, {});

        function ae() {}

        function ie(e) {
            return e
        }

        function M(e, n) {
            return e == null || e === ie ? n : function(s) {
                return n(e(s))
            }
        }

        function ne(e, n) {
            return function() {
                e.apply(this, arguments), n.apply(this, arguments)
            }
        }

        function Et(e, n) {
            return e === ae ? n : function() {
                var s = e.apply(this, arguments);
                s !== void 0 && (arguments[0] = s);
                var u = this.onsuccess,
                    l = this.onerror;
                this.onsuccess = null, this.onerror = null;
                var d = n.apply(this, arguments);
                return u && (this.onsuccess = this.onsuccess ? ne(u, this.onsuccess) : u), l && (this.onerror = this.onerror ? ne(l, this.onerror) : l), d !== void 0 ? d : s
            }
        }

        function Be(e, n) {
            return e === ae ? n : function() {
                e.apply(this, arguments);
                var s = this.onsuccess,
                    u = this.onerror;
                this.onsuccess = this.onerror = null, n.apply(this, arguments), s && (this.onsuccess = this.onsuccess ? ne(s, this.onsuccess) : s), u && (this.onerror = this.onerror ? ne(u, this.onerror) : u)
            }
        }

        function Kr(e, n) {
            return e === ae ? n : function(s) {
                var u = e.apply(this, arguments);
                m(s, u);
                var l = this.onsuccess,
                    d = this.onerror;
                return this.onsuccess = null, this.onerror = null, s = n.apply(this, arguments), l && (this.onsuccess = this.onsuccess ? ne(l, this.onsuccess) : l), d && (this.onerror = this.onerror ? ne(d, this.onerror) : d), u === void 0 ? s === void 0 ? void 0 : s : m(u, s)
            }
        }

        function Ur(e, n) {
            return e === ae ? n : function() {
                return n.apply(this, arguments) !== !1 && e.apply(this, arguments)
            }
        }

        function Rn(e, n) {
            return e === ae ? n : function() {
                var s = e.apply(this, arguments);
                if (s && typeof s.then == "function") {
                    for (var u = this, l = arguments.length, d = new Array(l); l--;) d[l] = arguments[l];
                    return s.then(function() {
                        return n.apply(u, d)
                    })
                }
                return n.apply(this, arguments)
            }
        }
        ge.ModifyError = ft, ge.DexieError = Ze, ge.BulkError = We;
        var st = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);

        function Gn(e) {
            st = e
        }
        var $t = {},
            Yn = 100,
            Tt = typeof Promise > "u" ? [] : function() {
                var e = Promise.resolve();
                if (typeof crypto > "u" || !crypto.subtle) return [e, v(e), e];
                var n = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
                return [n, v(n), e]
            }(),
            Pe = Tt[0],
            ut = Tt[1],
            Tt = Tt[2],
            ut = ut && ut.then,
            j = Pe && Pe.constructor,
            V = !!Tt,
            ve = function(e, n) {
                Sn.push([e, n]), rt && (queueMicrotask(Xi), rt = !1)
            },
            Se = !0,
            rt = !0,
            it = [],
            dt = [],
            On = ie,
            Pt = {
                id: "global",
                global: !0,
                ref: 0,
                unhandleds: [],
                onunhandled: ae,
                pgp: !1,
                env: {},
                finalize: ae
            },
            ee = Pt,
            Sn = [],
            Wt = 0,
            Jn = [];

        function J(e) {
            if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
            this._listeners = [], this._lib = !1;
            var n = this._PSD = ee;
            if (typeof e != "function") {
                if (e !== $t) throw new TypeError("Not a function");
                return this._state = arguments[1], this._value = arguments[2], void(this._state === !1 && Vr(this, this._value))
            }
            this._state = null, this._value = null, ++n.ref,
                function s(u, l) {
                    try {
                        l(function(d) {
                            if (u._state === null) {
                                if (d === u) throw new TypeError("A promise cannot be resolved with itself.");
                                var h = u._lib && nn();
                                d && typeof d.then == "function" ? s(u, function(y, R) {
                                    d instanceof J ? d._then(y, R) : d.then(y, R)
                                }) : (u._state = !0, u._value = d, fa(u)), h && rn()
                            }
                        }, Vr.bind(null, u))
                    } catch (d) {
                        Vr(u, d)
                    }
                }(this, e)
        }
        var qr = {
            get: function() {
                var e = ee,
                    n = er;

                function s(u, l) {
                    var d = this,
                        h = !e.global && (e !== ee || n !== er),
                        y = h && !Lt(),
                        R = new J(function(w, k) {
                            Hr(d, new la(ha(u, e, h, y), ha(l, e, h, y), w, k, e))
                        });
                    return this._consoleTask && (R._consoleTask = this._consoleTask), R
                }
                return s.prototype = $t, s
            },
            set: function(e) {
                B(this, "then", e && e.prototype === $t ? qr : {
                    get: function() {
                        return e
                    },
                    set: qr.set
                })
            }
        };

        function la(e, n, s, u, l) {
            this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof n == "function" ? n : null, this.resolve = s, this.reject = u, this.psd = l
        }

        function Vr(e, n) {
            var s, u;
            dt.push(n), e._state === null && (s = e._lib && nn(), n = On(n), e._state = !1, e._value = n, u = e, it.some(function(l) {
                return l._value === u._value
            }) || it.push(u), fa(e), s && rn())
        }

        function fa(e) {
            var n = e._listeners;
            e._listeners = [];
            for (var s = 0, u = n.length; s < u; ++s) Hr(e, n[s]);
            var l = e._PSD;
            --l.ref || l.finalize(), Wt === 0 && (++Wt, ve(function() {
                --Wt == 0 && $r()
            }, []))
        }

        function Hr(e, n) {
            if (e._state !== null) {
                var s = e._state ? n.onFulfilled : n.onRejected;
                if (s === null) return (e._state ? n.resolve : n.reject)(e._value);
                ++n.psd.ref, ++Wt, ve(Ji, [s, e, n])
            } else e._listeners.push(n)
        }

        function Ji(e, n, s) {
            try {
                var u, l = n._value;
                !n._state && dt.length && (dt = []), u = st && n._consoleTask ? n._consoleTask.run(function() {
                    return e(l)
                }) : e(l), n._state || dt.indexOf(l) !== -1 || function(d) {
                    for (var h = it.length; h;)
                        if (it[--h]._value === d._value) return it.splice(h, 1)
                }(n), s.resolve(u)
            } catch (d) {
                s.reject(d)
            } finally {
                --Wt == 0 && $r(), --s.psd.ref || s.psd.finalize()
            }
        }

        function Xi() {
            zt(Pt, function() {
                nn() && rn()
            })
        }

        function nn() {
            var e = Se;
            return rt = Se = !1, e
        }

        function rn() {
            var e, n, s;
            do
                for (; 0 < Sn.length;)
                    for (e = Sn, Sn = [], s = e.length, n = 0; n < s; ++n) {
                        var u = e[n];
                        u[0].apply(null, u[1])
                    }
            while (0 < Sn.length);
            rt = Se = !0
        }

        function $r() {
            var e = it;
            it = [], e.forEach(function(u) {
                u._PSD.onunhandled.call(null, u._value, u)
            });
            for (var n = Jn.slice(0), s = n.length; s;) n[--s]()
        }

        function Xn(e) {
            return new J($t, !1, e)
        }

        function xe(e, n) {
            var s = ee;
            return function() {
                var u = nn(),
                    l = ee;
                try {
                    return Ft(s, !0), e.apply(this, arguments)
                } catch (d) {
                    n && n(d)
                } finally {
                    Ft(l, !1), u && rn()
                }
            }
        }
        T(J.prototype, {
            then: qr,
            _then: function(e, n) {
                Hr(this, new la(null, null, e, n, ee))
            },
            catch: function(e) {
                if (arguments.length === 1) return this.then(null, e);
                var n = e,
                    s = arguments[1];
                return typeof n == "function" ? this.then(null, function(u) {
                    return (u instanceof n ? s : Xn)(u)
                }) : this.then(null, function(u) {
                    return (u && u.name === n ? s : Xn)(u)
                })
            },
            finally: function(e) {
                return this.then(function(n) {
                    return J.resolve(e()).then(function() {
                        return n
                    })
                }, function(n) {
                    return J.resolve(e()).then(function() {
                        return Xn(n)
                    })
                })
            },
            timeout: function(e, n) {
                var s = this;
                return e < 1 / 0 ? new J(function(u, l) {
                    var d = setTimeout(function() {
                        return l(new F.Timeout(n))
                    }, e);
                    s.then(u, l).finally(clearTimeout.bind(null, d))
                }) : this
            }
        }), typeof Symbol < "u" && Symbol.toStringTag && B(J.prototype, Symbol.toStringTag, "Dexie.Promise"), Pt.env = da(), T(J, {
            all: function() {
                var e = $e.apply(null, arguments).map(tr);
                return new J(function(n, s) {
                    e.length === 0 && n([]);
                    var u = e.length;
                    e.forEach(function(l, d) {
                        return J.resolve(l).then(function(h) {
                            e[d] = h, --u || n(e)
                        }, s)
                    })
                })
            },
            resolve: function(e) {
                return e instanceof J ? e : e && typeof e.then == "function" ? new J(function(n, s) {
                    e.then(n, s)
                }) : new J($t, !0, e)
            },
            reject: Xn,
            race: function() {
                var e = $e.apply(null, arguments).map(tr);
                return new J(function(n, s) {
                    e.map(function(u) {
                        return J.resolve(u).then(n, s)
                    })
                })
            },
            PSD: {
                get: function() {
                    return ee
                },
                set: function(e) {
                    return ee = e
                }
            },
            totalEchoes: {
                get: function() {
                    return er
                }
            },
            newPSD: Nt,
            usePSD: zt,
            scheduler: {
                get: function() {
                    return ve
                },
                set: function(e) {
                    ve = e
                }
            },
            rejectionMapper: {
                get: function() {
                    return On
                },
                set: function(e) {
                    On = e
                }
            },
            follow: function(e, n) {
                return new J(function(s, u) {
                    return Nt(function(l, d) {
                        var h = ee;
                        h.unhandleds = [], h.onunhandled = d, h.finalize = ne(function() {
                            var y, R = this;
                            y = function() {
                                R.unhandleds.length === 0 ? l() : d(R.unhandleds[0])
                            }, Jn.push(function w() {
                                y(), Jn.splice(Jn.indexOf(w), 1)
                            }), ++Wt, ve(function() {
                                --Wt == 0 && $r()
                            }, [])
                        }, h.finalize), e()
                    }, n, s, u)
                })
            }
        }), j && (j.allSettled && B(J, "allSettled", function() {
            var e = $e.apply(null, arguments).map(tr);
            return new J(function(n) {
                e.length === 0 && n([]);
                var s = e.length,
                    u = new Array(s);
                e.forEach(function(l, d) {
                    return J.resolve(l).then(function(h) {
                        return u[d] = {
                            status: "fulfilled",
                            value: h
                        }
                    }, function(h) {
                        return u[d] = {
                            status: "rejected",
                            reason: h
                        }
                    }).then(function() {
                        return --s || n(u)
                    })
                })
            })
        }), j.any && typeof AggregateError < "u" && B(J, "any", function() {
            var e = $e.apply(null, arguments).map(tr);
            return new J(function(n, s) {
                e.length === 0 && s(new AggregateError([]));
                var u = e.length,
                    l = new Array(u);
                e.forEach(function(d, h) {
                    return J.resolve(d).then(function(y) {
                        return n(y)
                    }, function(y) {
                        l[h] = y, --u || s(new AggregateError(l))
                    })
                })
            })
        }));
        var Ke = {
                awaits: 0,
                echoes: 0,
                id: 0
            },
            Qi = 0,
            Qn = [],
            Zn = 0,
            er = 0,
            Zi = 0;

        function Nt(e, n, s, u) {
            var l = ee,
                d = Object.create(l);
            return d.parent = l, d.ref = 0, d.global = !1, d.id = ++Zi, Pt.env, d.env = V ? {
                Promise: J,
                PromiseProp: {
                    value: J,
                    configurable: !0,
                    writable: !0
                },
                all: J.all,
                race: J.race,
                allSettled: J.allSettled,
                any: J.any,
                resolve: J.resolve,
                reject: J.reject
            } : {}, n && m(d, n), ++l.ref, d.finalize = function() {
                --this.parent.ref || this.parent.finalize()
            }, u = zt(d, e, s, u), d.ref === 0 && d.finalize(), u
        }

        function on() {
            return Ke.id || (Ke.id = ++Qi), ++Ke.awaits, Ke.echoes += Yn, Ke.id
        }

        function Lt() {
            return !!Ke.awaits && (--Ke.awaits == 0 && (Ke.id = 0), Ke.echoes = Ke.awaits * Yn, !0)
        }

        function tr(e) {
            return Ke.echoes && e && e.constructor === j ? (on(), e.then(function(n) {
                return Lt(), n
            }, function(n) {
                return Lt(), Ie(n)
            })) : e
        }

        function eu() {
            var e = Qn[Qn.length - 1];
            Qn.pop(), Ft(e, !1)
        }

        function Ft(e, n) {
            var s, u = ee;
            (n ? !Ke.echoes || Zn++ && e === ee : !Zn || --Zn && e === ee) || queueMicrotask(n ? (function(l) {
                ++er, Ke.echoes && --Ke.echoes != 0 || (Ke.echoes = Ke.awaits = Ke.id = 0), Qn.push(ee), Ft(l, !0)
            }).bind(null, e) : eu), e !== ee && (ee = e, u === Pt && (Pt.env = da()), V && (s = Pt.env.Promise, n = e.env, (u.global || e.global) && (Object.defineProperty(i, "Promise", n.PromiseProp), s.all = n.all, s.race = n.race, s.resolve = n.resolve, s.reject = n.reject, n.allSettled && (s.allSettled = n.allSettled), n.any && (s.any = n.any))))
        }

        function da() {
            var e = i.Promise;
            return V ? {
                Promise: e,
                PromiseProp: Object.getOwnPropertyDescriptor(i, "Promise"),
                all: e.all,
                race: e.race,
                allSettled: e.allSettled,
                any: e.any,
                resolve: e.resolve,
                reject: e.reject
            } : {}
        }

        function zt(e, n, s, u, l) {
            var d = ee;
            try {
                return Ft(e, !0), n(s, u, l)
            } finally {
                Ft(d, !1)
            }
        }

        function ha(e, n, s, u) {
            return typeof e != "function" ? e : function() {
                var l = ee;
                s && on(), Ft(n, !0);
                try {
                    return e.apply(this, arguments)
                } finally {
                    Ft(l, !1), u && queueMicrotask(Lt)
                }
            }
        }

        function Wr(e) {
            Promise === j && Ke.echoes === 0 ? Zn === 0 ? e() : enqueueNativeMicroTask(e) : setTimeout(e, 0)
        }("" + ut).indexOf("[native code]") === -1 && (on = Lt = ae);
        var Ie = J.reject,
            Gt = "ï¿¿",
            xt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.",
            pa = "String expected.",
            an = [],
            nr = "__dbnames",
            zr = "readonly",
            Gr = "readwrite";

        function Yt(e, n) {
            return e ? n ? function() {
                return e.apply(this, arguments) && n.apply(this, arguments)
            } : e : n
        }
        var ma = {
            type: 3,
            lower: -1 / 0,
            lowerOpen: !1,
            upper: [
                []
            ],
            upperOpen: !1
        };

        function rr(e) {
            return typeof e != "string" || /\./.test(e) ? function(n) {
                return n
            } : function(n) {
                return n[e] === void 0 && e in n && delete(n = Fe(n))[e], n
            }
        }

        function ya() {
            throw F.Type()
        }

        function we(e, n) {
            try {
                var s = ga(e),
                    u = ga(n);
                if (s !== u) return s === "Array" ? 1 : u === "Array" ? -1 : s === "binary" ? 1 : u === "binary" ? -1 : s === "string" ? 1 : u === "string" ? -1 : s === "Date" ? 1 : u !== "Date" ? NaN : -1;
                switch (s) {
                    case "number":
                    case "Date":
                    case "string":
                        return n < e ? 1 : e < n ? -1 : 0;
                    case "binary":
                        return function(l, d) {
                            for (var h = l.length, y = d.length, R = h < y ? h : y, w = 0; w < R; ++w)
                                if (l[w] !== d[w]) return l[w] < d[w] ? -1 : 1;
                            return h === y ? 0 : h < y ? -1 : 1
                        }(va(e), va(n));
                    case "Array":
                        return function(l, d) {
                            for (var h = l.length, y = d.length, R = h < y ? h : y, w = 0; w < R; ++w) {
                                var k = we(l[w], d[w]);
                                if (k !== 0) return k
                            }
                            return h === y ? 0 : h < y ? -1 : 1
                        }(e, n)
                }
            } catch (l) {}
            return NaN
        }

        function ga(e) {
            var n = typeof e;
            return n != "object" ? n : ArrayBuffer.isView(e) ? "binary" : (e = He(e), e === "ArrayBuffer" ? "binary" : e)
        }

        function va(e) {
            return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e)
        }
        var ba = (ke.prototype._trans = function(e, n, s) {
            var u = this._tx || ee.trans,
                l = this.name,
                d = st && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(e === "readonly" ? "read" : "write", " ").concat(this.name));

            function h(w, k, b) {
                if (!b.schema[l]) throw new F.NotFound("Table " + l + " not part of transaction");
                return n(b.idbtrans, b)
            }
            var y = nn();
            try {
                var R = u && u.db._novip === this.db._novip ? u === ee.trans ? u._promise(e, h, s) : Nt(function() {
                    return u._promise(e, h, s)
                }, {
                    trans: u,
                    transless: ee.transless || ee
                }) : function w(k, b, P, E) {
                    if (k.idbdb && (k._state.openComplete || ee.letThrough || k._vip)) {
                        var S = k._createTransaction(b, P, k._dbSchema);
                        try {
                            S.create(), k._state.PR1398_maxLoop = 3
                        } catch (x) {
                            return x.name === K.InvalidState && k.isOpen() && 0 < --k._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), k.close({
                                disableAutoOpen: !1
                            }), k.open().then(function() {
                                return w(k, b, P, E)
                            })) : Ie(x)
                        }
                        return S._promise(b, function(x, O) {
                            return Nt(function() {
                                return ee.trans = S, E(x, O, S)
                            })
                        }).then(function(x) {
                            if (b === "readwrite") try {
                                S.idbtrans.commit()
                            } catch (O) {}
                            return b === "readonly" ? x : S._completion.then(function() {
                                return x
                            })
                        })
                    }
                    if (k._state.openComplete) return Ie(new F.DatabaseClosed(k._state.dbOpenError));
                    if (!k._state.isBeingOpened) {
                        if (!k._state.autoOpen) return Ie(new F.DatabaseClosed);
                        k.open().catch(ae)
                    }
                    return k._state.dbReadyPromise.then(function() {
                        return w(k, b, P, E)
                    })
                }(this.db, e, [this.name], h);
                return d && (R._consoleTask = d, R = R.catch(function(w) {
                    return console.trace(w), Ie(w)
                })), R
            } finally {
                y && rn()
            }
        }, ke.prototype.get = function(e, n) {
            var s = this;
            return e && e.constructor === Object ? this.where(e).first(n) : e == null ? Ie(new F.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(u) {
                return s.core.get({
                    trans: u,
                    key: e
                }).then(function(l) {
                    return s.hook.reading.fire(l)
                })
            }).then(n)
        }, ke.prototype.where = function(e) {
            if (typeof e == "string") return new this.db.WhereClause(this, e);
            if (p(e)) return new this.db.WhereClause(this, "[".concat(e.join("+"), "]"));
            var n = f(e);
            if (n.length === 1) return this.where(n[0]).equals(e[n[0]]);
            var s = this.schema.indexes.concat(this.schema.primKey).filter(function(R) {
                if (R.compound && n.every(function(k) {
                        return 0 <= R.keyPath.indexOf(k)
                    })) {
                    for (var w = 0; w < n.length; ++w)
                        if (n.indexOf(R.keyPath[w]) === -1) return !1;
                    return !0
                }
                return !1
            }).sort(function(R, w) {
                return R.keyPath.length - w.keyPath.length
            })[0];
            if (s && this.db._maxKey !== Gt) {
                var h = s.keyPath.slice(0, n.length);
                return this.where(h).equals(h.map(function(w) {
                    return e[w]
                }))
            }!s && st && console.warn("The query ".concat(JSON.stringify(e), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(n.join("+"), "]"));
            var u = this.schema.idxByName,
                l = this.db._deps.indexedDB;

            function d(R, w) {
                return l.cmp(R, w) === 0
            }
            var y = n.reduce(function(P, w) {
                    var k = P[0],
                        b = P[1],
                        P = u[w],
                        E = e[w];
                    return [k || P, k || !P ? Yt(b, P && P.multi ? function(S) {
                        return S = me(S, w), p(S) && S.some(function(x) {
                            return d(E, x)
                        })
                    } : function(S) {
                        return d(E, me(S, w))
                    }) : b]
                }, [null, null]),
                h = y[0],
                y = y[1];
            return h ? this.where(h.name).equals(e[h.keyPath]).filter(y) : s ? this.filter(y) : this.where(n).equals("")
        }, ke.prototype.filter = function(e) {
            return this.toCollection().and(e)
        }, ke.prototype.count = function(e) {
            return this.toCollection().count(e)
        }, ke.prototype.offset = function(e) {
            return this.toCollection().offset(e)
        }, ke.prototype.limit = function(e) {
            return this.toCollection().limit(e)
        }, ke.prototype.each = function(e) {
            return this.toCollection().each(e)
        }, ke.prototype.toArray = function(e) {
            return this.toCollection().toArray(e)
        }, ke.prototype.toCollection = function() {
            return new this.db.Collection(new this.db.WhereClause(this))
        }, ke.prototype.orderBy = function(e) {
            return new this.db.Collection(new this.db.WhereClause(this, p(e) ? "[".concat(e.join("+"), "]") : e))
        }, ke.prototype.reverse = function() {
            return this.toCollection().reverse()
        }, ke.prototype.mapToClass = function(e) {
            var n, s = this.db,
                u = this.name;

            function l() {
                return n !== null && n.apply(this, arguments) || this
            }(this.schema.mappedClass = e).prototype instanceof ya && (function(R, w) {
                if (typeof w != "function" && w !== null) throw new TypeError("Class extends value " + String(w) + " is not a constructor or null");

                function k() {
                    this.constructor = R
                }
                o(R, w), R.prototype = w === null ? Object.create(w) : (k.prototype = w.prototype, new k)
            }(l, n = e), Object.defineProperty(l.prototype, "db", {
                get: function() {
                    return s
                },
                enumerable: !1,
                configurable: !0
            }), l.prototype.table = function() {
                return u
            }, e = l);
            for (var d = new Set, h = e.prototype; h; h = v(h)) Object.getOwnPropertyNames(h).forEach(function(R) {
                return d.add(R)
            });

            function y(R) {
                if (!R) return R;
                var w, k = Object.create(e.prototype);
                for (w in R)
                    if (!d.has(w)) try {
                        k[w] = R[w]
                    } catch (b) {}
                return k
            }
            return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = y, this.hook("reading", y), e
        }, ke.prototype.defineClass = function() {
            return this.mapToClass(function(e) {
                m(this, e)
            })
        }, ke.prototype.add = function(e, n) {
            var s = this,
                u = this.schema.primKey,
                l = u.auto,
                d = u.keyPath,
                h = e;
            return d && l && (h = rr(d)(e)), this._trans("readwrite", function(y) {
                return s.core.mutate({
                    trans: y,
                    type: "add",
                    keys: n != null ? [n] : null,
                    values: [h]
                })
            }).then(function(y) {
                return y.numFailures ? J.reject(y.failures[0]) : y.lastResult
            }).then(function(y) {
                if (d) try {
                    se(e, d, y)
                } catch (R) {}
                return y
            })
        }, ke.prototype.update = function(e, n) {
            return typeof e != "object" || p(e) ? this.where(":id").equals(e).modify(n) : (e = me(e, this.schema.primKey.keyPath), e === void 0 ? Ie(new F.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e).modify(n))
        }, ke.prototype.put = function(e, n) {
            var s = this,
                u = this.schema.primKey,
                l = u.auto,
                d = u.keyPath,
                h = e;
            return d && l && (h = rr(d)(e)), this._trans("readwrite", function(y) {
                return s.core.mutate({
                    trans: y,
                    type: "put",
                    values: [h],
                    keys: n != null ? [n] : null
                })
            }).then(function(y) {
                return y.numFailures ? J.reject(y.failures[0]) : y.lastResult
            }).then(function(y) {
                if (d) try {
                    se(e, d, y)
                } catch (R) {}
                return y
            })
        }, ke.prototype.delete = function(e) {
            var n = this;
            return this._trans("readwrite", function(s) {
                return n.core.mutate({
                    trans: s,
                    type: "delete",
                    keys: [e]
                })
            }).then(function(s) {
                return s.numFailures ? J.reject(s.failures[0]) : void 0
            })
        }, ke.prototype.clear = function() {
            var e = this;
            return this._trans("readwrite", function(n) {
                return e.core.mutate({
                    trans: n,
                    type: "deleteRange",
                    range: ma
                })
            }).then(function(n) {
                return n.numFailures ? J.reject(n.failures[0]) : void 0
            })
        }, ke.prototype.bulkGet = function(e) {
            var n = this;
            return this._trans("readonly", function(s) {
                return n.core.getMany({
                    keys: e,
                    trans: s
                }).then(function(u) {
                    return u.map(function(l) {
                        return n.hook.reading.fire(l)
                    })
                })
            })
        }, ke.prototype.bulkAdd = function(e, n, s) {
            var u = this,
                l = Array.isArray(n) ? n : void 0,
                d = (s = s || (l ? void 0 : n)) ? s.allKeys : void 0;
            return this._trans("readwrite", function(h) {
                var w = u.schema.primKey,
                    y = w.auto,
                    w = w.keyPath;
                if (w && l) throw new F.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
                if (l && l.length !== e.length) throw new F.InvalidArgument("Arguments objects and keys must have the same length");
                var R = e.length,
                    w = w && y ? e.map(rr(w)) : e;
                return u.core.mutate({
                    trans: h,
                    type: "add",
                    keys: l,
                    values: w,
                    wantResults: d
                }).then(function(S) {
                    var b = S.numFailures,
                        P = S.results,
                        E = S.lastResult,
                        S = S.failures;
                    if (b === 0) return d ? P : E;
                    throw new We("".concat(u.name, ".bulkAdd(): ").concat(b, " of ").concat(R, " operations failed"), S)
                })
            })
        }, ke.prototype.bulkPut = function(e, n, s) {
            var u = this,
                l = Array.isArray(n) ? n : void 0,
                d = (s = s || (l ? void 0 : n)) ? s.allKeys : void 0;
            return this._trans("readwrite", function(h) {
                var w = u.schema.primKey,
                    y = w.auto,
                    w = w.keyPath;
                if (w && l) throw new F.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
                if (l && l.length !== e.length) throw new F.InvalidArgument("Arguments objects and keys must have the same length");
                var R = e.length,
                    w = w && y ? e.map(rr(w)) : e;
                return u.core.mutate({
                    trans: h,
                    type: "put",
                    keys: l,
                    values: w,
                    wantResults: d
                }).then(function(S) {
                    var b = S.numFailures,
                        P = S.results,
                        E = S.lastResult,
                        S = S.failures;
                    if (b === 0) return d ? P : E;
                    throw new We("".concat(u.name, ".bulkPut(): ").concat(b, " of ").concat(R, " operations failed"), S)
                })
            })
        }, ke.prototype.bulkUpdate = function(e) {
            var n = this,
                s = this.core,
                u = e.map(function(h) {
                    return h.key
                }),
                l = e.map(function(h) {
                    return h.changes
                }),
                d = [];
            return this._trans("readwrite", function(h) {
                return s.getMany({
                    trans: h,
                    keys: u,
                    cache: "clone"
                }).then(function(y) {
                    var R = [],
                        w = [];
                    e.forEach(function(b, P) {
                        var E = b.key,
                            S = b.changes,
                            x = y[P];
                        if (x) {
                            for (var O = 0, C = Object.keys(S); O < C.length; O++) {
                                var I = C[O],
                                    N = S[I];
                                if (I === n.schema.primKey.keyPath) {
                                    if (we(N, E) !== 0) throw new F.Constraint("Cannot update primary key in bulkUpdate()")
                                } else se(x, I, N)
                            }
                            d.push(P), R.push(E), w.push(x)
                        }
                    });
                    var k = R.length;
                    return s.mutate({
                        trans: h,
                        type: "put",
                        keys: R,
                        values: w,
                        updates: {
                            keys: u,
                            changeSpecs: l
                        }
                    }).then(function(b) {
                        var P = b.numFailures,
                            E = b.failures;
                        if (P === 0) return k;
                        for (var S = 0, x = Object.keys(E); S < x.length; S++) {
                            var O, C = x[S],
                                I = d[Number(C)];
                            I != null && (O = E[C], delete E[C], E[I] = O)
                        }
                        throw new We("".concat(n.name, ".bulkUpdate(): ").concat(P, " of ").concat(k, " operations failed"), E)
                    })
                })
            })
        }, ke.prototype.bulkDelete = function(e) {
            var n = this,
                s = e.length;
            return this._trans("readwrite", function(u) {
                return n.core.mutate({
                    trans: u,
                    type: "delete",
                    keys: e
                })
            }).then(function(h) {
                var l = h.numFailures,
                    d = h.lastResult,
                    h = h.failures;
                if (l === 0) return d;
                throw new We("".concat(n.name, ".bulkDelete(): ").concat(l, " of ").concat(s, " operations failed"), h)
            })
        }, ke);

        function ke() {}

        function kn(e) {
            function n(h, y) {
                if (y) {
                    for (var R = arguments.length, w = new Array(R - 1); --R;) w[R - 1] = arguments[R];
                    return s[h].subscribe.apply(null, w), e
                }
                if (typeof h == "string") return s[h]
            }
            var s = {};
            n.addEventType = d;
            for (var u = 1, l = arguments.length; u < l; ++u) d(arguments[u]);
            return n;

            function d(h, y, R) {
                if (typeof h != "object") {
                    var w;
                    y = y || Ur;
                    var k = {
                        subscribers: [],
                        fire: R = R || ae,
                        subscribe: function(b) {
                            k.subscribers.indexOf(b) === -1 && (k.subscribers.push(b), k.fire = y(k.fire, b))
                        },
                        unsubscribe: function(b) {
                            k.subscribers = k.subscribers.filter(function(P) {
                                return P !== b
                            }), k.fire = k.subscribers.reduce(y, R)
                        }
                    };
                    return s[h] = n[h] = k
                }
                f(w = h).forEach(function(b) {
                    var P = w[b];
                    if (p(P)) d(b, w[b][0], w[b][1]);
                    else {
                        if (P !== "asap") throw new F.InvalidArgument("Invalid event config");
                        var E = d(b, ie, function() {
                            for (var S = arguments.length, x = new Array(S); S--;) x[S] = arguments[S];
                            E.subscribers.forEach(function(O) {
                                _e(function() {
                                    O.apply(null, x)
                                })
                            })
                        })
                    }
                })
            }
        }

        function Pn(e, n) {
            return q(n).from({
                prototype: e
            }), n
        }

        function sn(e, n) {
            return !(e.filter || e.algorithm || e.or) && (n ? e.justLimit : !e.replayFilter)
        }

        function Yr(e, n) {
            e.filter = Yt(e.filter, n)
        }

        function Jr(e, n, s) {
            var u = e.replayFilter;
            e.replayFilter = u ? function() {
                return Yt(u(), n())
            } : n, e.justLimit = s && !u
        }

        function or(e, n) {
            if (e.isPrimKey) return n.primaryKey;
            var s = n.getIndexByKeyPath(e.index);
            if (!s) throw new F.Schema("KeyPath " + e.index + " on object store " + n.name + " is not indexed");
            return s
        }

        function _a(e, n, s) {
            var u = or(e, n.schema);
            return n.openCursor({
                trans: s,
                values: !e.keysOnly,
                reverse: e.dir === "prev",
                unique: !!e.unique,
                query: {
                    index: u,
                    range: e.range
                }
            })
        }

        function ar(e, n, s, u) {
            var l = e.replayFilter ? Yt(e.filter, e.replayFilter()) : e.filter;
            if (e.or) {
                var d = {},
                    h = function(y, R, w) {
                        var k, b;
                        l && !l(R, w, function(P) {
                            return R.stop(P)
                        }, function(P) {
                            return R.fail(P)
                        }) || ((b = "" + (k = R.primaryKey)) == "[object ArrayBuffer]" && (b = "" + new Uint8Array(k)), _(d, b) || (d[b] = !0, n(y, R, w)))
                    };
                return Promise.all([e.or._iterate(h, s), wa(_a(e, u, s), e.algorithm, h, !e.keysOnly && e.valueMapper)])
            }
            return wa(_a(e, u, s), Yt(e.algorithm, l), n, !e.keysOnly && e.valueMapper)
        }

        function wa(e, n, s, u) {
            var l = xe(u ? function(d, h, y) {
                return s(u(d), h, y)
            } : s);
            return e.then(function(d) {
                if (d) return d.start(function() {
                    var h = function() {
                        return d.continue()
                    };
                    n && !n(d, function(y) {
                        return h = y
                    }, function(y) {
                        d.stop(y), h = ae
                    }, function(y) {
                        d.fail(y), h = ae
                    }) || l(d.value, d, function(y) {
                        return h = y
                    }), h()
                })
            })
        }
        var Tt = Symbol(),
            xn = (Ea.prototype.execute = function(e) {
                if (this.add !== void 0) {
                    var n = this.add;
                    if (p(n)) return c(c([], p(e) ? e : [], !0), n).sort();
                    if (typeof n == "number") return (Number(e) || 0) + n;
                    if (typeof n == "bigint") try {
                        return BigInt(e) + n
                    } catch (u) {
                        return BigInt(0) + n
                    }
                    throw new TypeError("Invalid term ".concat(n))
                }
                if (this.remove !== void 0) {
                    var s = this.remove;
                    if (p(s)) return p(e) ? e.filter(function(u) {
                        return !s.includes(u)
                    }).sort() : [];
                    if (typeof s == "number") return Number(e) - s;
                    if (typeof s == "bigint") try {
                        return BigInt(e) - s
                    } catch (u) {
                        return BigInt(0) - s
                    }
                    throw new TypeError("Invalid subtrahend ".concat(s))
                }
                return n = (n = this.replacePrefix) === null || n === void 0 ? void 0 : n[0], n && typeof e == "string" && e.startsWith(n) ? this.replacePrefix[1] + e.substring(n.length) : e
            }, Ea);

        function Ea(e) {
            Object.assign(this, e)
        }
        var tu = (be.prototype._read = function(e, n) {
            var s = this._ctx;
            return s.error ? s.table._trans(null, Ie.bind(null, s.error)) : s.table._trans("readonly", e).then(n)
        }, be.prototype._write = function(e) {
            var n = this._ctx;
            return n.error ? n.table._trans(null, Ie.bind(null, n.error)) : n.table._trans("readwrite", e, "locked")
        }, be.prototype._addAlgorithm = function(e) {
            var n = this._ctx;
            n.algorithm = Yt(n.algorithm, e)
        }, be.prototype._iterate = function(e, n) {
            return ar(this._ctx, e, n, this._ctx.table.core)
        }, be.prototype.clone = function(e) {
            var n = Object.create(this.constructor.prototype),
                s = Object.create(this._ctx);
            return e && m(s, e), n._ctx = s, n
        }, be.prototype.raw = function() {
            return this._ctx.valueMapper = null, this
        }, be.prototype.each = function(e) {
            var n = this._ctx;
            return this._read(function(s) {
                return ar(n, e, s, n.table.core)
            })
        }, be.prototype.count = function(e) {
            var n = this;
            return this._read(function(s) {
                var u = n._ctx,
                    l = u.table.core;
                if (sn(u, !0)) return l.count({
                    trans: s,
                    query: {
                        index: or(u, l.schema),
                        range: u.range
                    }
                }).then(function(h) {
                    return Math.min(h, u.limit)
                });
                var d = 0;
                return ar(u, function() {
                    return ++d, !1
                }, s, l).then(function() {
                    return d
                })
            }).then(e)
        }, be.prototype.sortBy = function(e, n) {
            var s = e.split(".").reverse(),
                u = s[0],
                l = s.length - 1;

            function d(R, w) {
                return w ? d(R[s[w]], w - 1) : R[u]
            }
            var h = this._ctx.dir === "next" ? 1 : -1;

            function y(R, w) {
                return R = d(R, l), w = d(w, l), R < w ? -h : w < R ? h : 0
            }
            return this.toArray(function(R) {
                return R.sort(y)
            }).then(n)
        }, be.prototype.toArray = function(e) {
            var n = this;
            return this._read(function(s) {
                var u = n._ctx;
                if (u.dir === "next" && sn(u, !0) && 0 < u.limit) {
                    var l = u.valueMapper,
                        d = or(u, u.table.core.schema);
                    return u.table.core.query({
                        trans: s,
                        limit: u.limit,
                        values: !0,
                        query: {
                            index: d,
                            range: u.range
                        }
                    }).then(function(y) {
                        return y = y.result, l ? y.map(l) : y
                    })
                }
                var h = [];
                return ar(u, function(y) {
                    return h.push(y)
                }, s, u.table.core).then(function() {
                    return h
                })
            }, e)
        }, be.prototype.offset = function(e) {
            var n = this._ctx;
            return e <= 0 || (n.offset += e, sn(n) ? Jr(n, function() {
                var s = e;
                return function(u, l) {
                    return s === 0 || (s === 1 ? --s : l(function() {
                        u.advance(s), s = 0
                    }), !1)
                }
            }) : Jr(n, function() {
                var s = e;
                return function() {
                    return --s < 0
                }
            })), this
        }, be.prototype.limit = function(e) {
            return this._ctx.limit = Math.min(this._ctx.limit, e), Jr(this._ctx, function() {
                var n = e;
                return function(s, u, l) {
                    return --n <= 0 && u(l), 0 <= n
                }
            }, !0), this
        }, be.prototype.until = function(e, n) {
            return Yr(this._ctx, function(s, u, l) {
                return !e(s.value) || (u(l), n)
            }), this
        }, be.prototype.first = function(e) {
            return this.limit(1).toArray(function(n) {
                return n[0]
            }).then(e)
        }, be.prototype.last = function(e) {
            return this.reverse().first(e)
        }, be.prototype.filter = function(e) {
            var n;
            return Yr(this._ctx, function(s) {
                return e(s.value)
            }), (n = this._ctx).isMatch = Yt(n.isMatch, e), this
        }, be.prototype.and = function(e) {
            return this.filter(e)
        }, be.prototype.or = function(e) {
            return new this.db.WhereClause(this._ctx.table, e, this)
        }, be.prototype.reverse = function() {
            return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this
        }, be.prototype.desc = function() {
            return this.reverse()
        }, be.prototype.eachKey = function(e) {
            var n = this._ctx;
            return n.keysOnly = !n.isMatch, this.each(function(s, u) {
                e(u.key, u)
            })
        }, be.prototype.eachUniqueKey = function(e) {
            return this._ctx.unique = "unique", this.eachKey(e)
        }, be.prototype.eachPrimaryKey = function(e) {
            var n = this._ctx;
            return n.keysOnly = !n.isMatch, this.each(function(s, u) {
                e(u.primaryKey, u)
            })
        }, be.prototype.keys = function(e) {
            var n = this._ctx;
            n.keysOnly = !n.isMatch;
            var s = [];
            return this.each(function(u, l) {
                s.push(l.key)
            }).then(function() {
                return s
            }).then(e)
        }, be.prototype.primaryKeys = function(e) {
            var n = this._ctx;
            if (n.dir === "next" && sn(n, !0) && 0 < n.limit) return this._read(function(u) {
                var l = or(n, n.table.core.schema);
                return n.table.core.query({
                    trans: u,
                    values: !1,
                    limit: n.limit,
                    query: {
                        index: l,
                        range: n.range
                    }
                })
            }).then(function(u) {
                return u.result
            }).then(e);
            n.keysOnly = !n.isMatch;
            var s = [];
            return this.each(function(u, l) {
                s.push(l.primaryKey)
            }).then(function() {
                return s
            }).then(e)
        }, be.prototype.uniqueKeys = function(e) {
            return this._ctx.unique = "unique", this.keys(e)
        }, be.prototype.firstKey = function(e) {
            return this.limit(1).keys(function(n) {
                return n[0]
            }).then(e)
        }, be.prototype.lastKey = function(e) {
            return this.reverse().firstKey(e)
        }, be.prototype.distinct = function() {
            var e = this._ctx,
                e = e.index && e.table.schema.idxByName[e.index];
            if (!e || !e.multi) return this;
            var n = {};
            return Yr(this._ctx, function(l) {
                var u = l.primaryKey.toString(),
                    l = _(n, u);
                return n[u] = !0, !l
            }), this
        }, be.prototype.modify = function(e) {
            var n = this,
                s = this._ctx;
            return this._write(function(u) {
                var l, d, h;
                h = typeof e == "function" ? e : (l = f(e), d = l.length, function(O) {
                    for (var C = !1, I = 0; I < d; ++I) {
                        var N = l[I],
                            D = e[N],
                            U = me(O, N);
                        D instanceof xn ? (se(O, N, D.execute(U)), C = !0) : U !== D && (se(O, N, D), C = !0)
                    }
                    return C
                });

                function y(O, N) {
                    var I = N.failures,
                        N = N.numFailures;
                    S += O - N;
                    for (var D = 0, U = f(I); D < U.length; D++) {
                        var G = U[D];
                        E.push(I[G])
                    }
                }
                var R = s.table.core,
                    w = R.schema.primaryKey,
                    k = w.outbound,
                    b = w.extractKey,
                    P = n.db._options.modifyChunkSize || 200,
                    E = [],
                    S = 0,
                    x = [];
                return n.clone().primaryKeys().then(function(O) {
                    function C(N) {
                        var D = Math.min(P, O.length - N);
                        return R.getMany({
                            trans: u,
                            keys: O.slice(N, N + D),
                            cache: "immutable"
                        }).then(function(U) {
                            for (var G = [], H = [], W = k ? [] : null, Y = [], $ = 0; $ < D; ++$) {
                                var ue = U[$],
                                    ce = {
                                        value: Fe(ue),
                                        primKey: O[N + $]
                                    };
                                h.call(ce, ce.value, ce) !== !1 && (ce.value == null ? Y.push(O[N + $]) : k || we(b(ue), b(ce.value)) === 0 ? (H.push(ce.value), k && W.push(O[N + $])) : (Y.push(O[N + $]), G.push(ce.value)))
                            }
                            return Promise.resolve(0 < G.length && R.mutate({
                                trans: u,
                                type: "add",
                                values: G
                            }).then(function(pe) {
                                for (var de in pe.failures) Y.splice(parseInt(de), 1);
                                y(G.length, pe)
                            })).then(function() {
                                return (0 < H.length || I && typeof e == "object") && R.mutate({
                                    trans: u,
                                    type: "put",
                                    keys: W,
                                    values: H,
                                    criteria: I,
                                    changeSpec: typeof e != "function" && e,
                                    isAdditionalChunk: 0 < N
                                }).then(function(pe) {
                                    return y(H.length, pe)
                                })
                            }).then(function() {
                                return (0 < Y.length || I && e === Xr) && R.mutate({
                                    trans: u,
                                    type: "delete",
                                    keys: Y,
                                    criteria: I,
                                    isAdditionalChunk: 0 < N
                                }).then(function(pe) {
                                    return y(Y.length, pe)
                                })
                            }).then(function() {
                                return O.length > N + D && C(N + P)
                            })
                        })
                    }
                    var I = sn(s) && s.limit === 1 / 0 && (typeof e != "function" || e === Xr) && {
                        index: s.index,
                        range: s.range
                    };
                    return C(0).then(function() {
                        if (0 < E.length) throw new ft("Error modifying one or more objects", E, S, x);
                        return O.length
                    })
                })
            })
        }, be.prototype.delete = function() {
            var e = this._ctx,
                n = e.range;
            return sn(e) && (e.isPrimKey || n.type === 3) ? this._write(function(s) {
                var u = e.table.core.schema.primaryKey,
                    l = n;
                return e.table.core.count({
                    trans: s,
                    query: {
                        index: u,
                        range: l
                    }
                }).then(function(d) {
                    return e.table.core.mutate({
                        trans: s,
                        type: "deleteRange",
                        range: l
                    }).then(function(h) {
                        var y = h.failures;
                        if (h.lastResult, h.results, h = h.numFailures, h) throw new ft("Could not delete some values", Object.keys(y).map(function(R) {
                            return y[R]
                        }), d - h);
                        return d - h
                    })
                })
            }) : this.modify(Xr)
        }, be);

        function be() {}
        var Xr = function(e, n) {
            return n.value = null
        };

        function nu(e, n) {
            return e < n ? -1 : e === n ? 0 : 1
        }

        function ru(e, n) {
            return n < e ? -1 : e === n ? 0 : 1
        }

        function ot(e, n, s) {
            return e = e instanceof Oa ? new e.Collection(e) : e, e._ctx.error = new(s || TypeError)(n), e
        }

        function un(e) {
            return new e.Collection(e, function() {
                return Ra("")
            }).limit(0)
        }

        function sr(e, n, s, u) {
            var l, d, h, y, R, w, k, b = s.length;
            if (!s.every(function(S) {
                    return typeof S == "string"
                })) return ot(e, pa);

            function P(S) {
                l = S === "next" ? function(O) {
                    return O.toUpperCase()
                } : function(O) {
                    return O.toLowerCase()
                }, d = S === "next" ? function(O) {
                    return O.toLowerCase()
                } : function(O) {
                    return O.toUpperCase()
                }, h = S === "next" ? nu : ru;
                var x = s.map(function(O) {
                    return {
                        lower: d(O),
                        upper: l(O)
                    }
                }).sort(function(O, C) {
                    return h(O.lower, C.lower)
                });
                y = x.map(function(O) {
                    return O.upper
                }), R = x.map(function(O) {
                    return O.lower
                }), k = (w = S) === "next" ? "" : u
            }
            P("next"), e = new e.Collection(e, function() {
                return Dt(y[0], R[b - 1] + u)
            }), e._ondirectionchange = function(S) {
                P(S)
            };
            var E = 0;
            return e._addAlgorithm(function(S, x, O) {
                var C = S.key;
                if (typeof C != "string") return !1;
                var I = d(C);
                if (n(I, R, E)) return !0;
                for (var N = null, D = E; D < b; ++D) {
                    var U = function(G, H, W, Y, $, ue) {
                        for (var ce = Math.min(G.length, Y.length), pe = -1, de = 0; de < ce; ++de) {
                            var ht = H[de];
                            if (ht !== Y[de]) return $(G[de], W[de]) < 0 ? G.substr(0, de) + W[de] + W.substr(de + 1) : $(G[de], Y[de]) < 0 ? G.substr(0, de) + Y[de] + W.substr(de + 1) : 0 <= pe ? G.substr(0, pe) + H[pe] + W.substr(pe + 1) : null;
                            $(G[de], ht) < 0 && (pe = de)
                        }
                        return ce < Y.length && ue === "next" ? G + W.substr(G.length) : ce < G.length && ue === "prev" ? G.substr(0, W.length) : pe < 0 ? null : G.substr(0, pe) + Y[pe] + W.substr(pe + 1)
                    }(C, I, y[D], R[D], h, w);
                    U === null && N === null ? E = D + 1 : (N === null || 0 < h(N, U)) && (N = U)
                }
                return x(N !== null ? function() {
                    S.continue(N + k)
                } : O), !1
            }), e
        }

        function Dt(e, n, s, u) {
            return {
                type: 2,
                lower: e,
                upper: n,
                lowerOpen: s,
                upperOpen: u
            }
        }

        function Ra(e) {
            return {
                type: 1,
                lower: e,
                upper: e
            }
        }
        var Oa = (Object.defineProperty(Ue.prototype, "Collection", {
            get: function() {
                return this._ctx.table.db.Collection
            },
            enumerable: !1,
            configurable: !0
        }), Ue.prototype.between = function(e, n, s, u) {
            s = s !== !1, u = u === !0;
            try {
                return 0 < this._cmp(e, n) || this._cmp(e, n) === 0 && (s || u) && (!s || !u) ? un(this) : new this.Collection(this, function() {
                    return Dt(e, n, !s, !u)
                })
            } catch (l) {
                return ot(this, xt)
            }
        }, Ue.prototype.equals = function(e) {
            return e == null ? ot(this, xt) : new this.Collection(this, function() {
                return Ra(e)
            })
        }, Ue.prototype.above = function(e) {
            return e == null ? ot(this, xt) : new this.Collection(this, function() {
                return Dt(e, void 0, !0)
            })
        }, Ue.prototype.aboveOrEqual = function(e) {
            return e == null ? ot(this, xt) : new this.Collection(this, function() {
                return Dt(e, void 0, !1)
            })
        }, Ue.prototype.below = function(e) {
            return e == null ? ot(this, xt) : new this.Collection(this, function() {
                return Dt(void 0, e, !1, !0)
            })
        }, Ue.prototype.belowOrEqual = function(e) {
            return e == null ? ot(this, xt) : new this.Collection(this, function() {
                return Dt(void 0, e)
            })
        }, Ue.prototype.startsWith = function(e) {
            return typeof e != "string" ? ot(this, pa) : this.between(e, e + Gt, !0, !0)
        }, Ue.prototype.startsWithIgnoreCase = function(e) {
            return e === "" ? this.startsWith(e) : sr(this, function(n, s) {
                return n.indexOf(s[0]) === 0
            }, [e], Gt)
        }, Ue.prototype.equalsIgnoreCase = function(e) {
            return sr(this, function(n, s) {
                return n === s[0]
            }, [e], "")
        }, Ue.prototype.anyOfIgnoreCase = function() {
            var e = $e.apply(at, arguments);
            return e.length === 0 ? un(this) : sr(this, function(n, s) {
                return s.indexOf(n) !== -1
            }, e, "")
        }, Ue.prototype.startsWithAnyOfIgnoreCase = function() {
            var e = $e.apply(at, arguments);
            return e.length === 0 ? un(this) : sr(this, function(n, s) {
                return s.some(function(u) {
                    return n.indexOf(u) === 0
                })
            }, e, Gt)
        }, Ue.prototype.anyOf = function() {
            var e = this,
                n = $e.apply(at, arguments),
                s = this._cmp;
            try {
                n.sort(s)
            } catch (d) {
                return ot(this, xt)
            }
            if (n.length === 0) return un(this);
            var u = new this.Collection(this, function() {
                return Dt(n[0], n[n.length - 1])
            });
            u._ondirectionchange = function(d) {
                s = d === "next" ? e._ascending : e._descending, n.sort(s)
            };
            var l = 0;
            return u._addAlgorithm(function(d, h, y) {
                for (var R = d.key; 0 < s(R, n[l]);)
                    if (++l === n.length) return h(y), !1;
                return s(R, n[l]) === 0 || (h(function() {
                    d.continue(n[l])
                }), !1)
            }), u
        }, Ue.prototype.notEqual = function(e) {
            return this.inAnyRange([
                [-1 / 0, e],
                [e, this.db._maxKey]
            ], {
                includeLowers: !1,
                includeUppers: !1
            })
        }, Ue.prototype.noneOf = function() {
            var e = $e.apply(at, arguments);
            if (e.length === 0) return new this.Collection(this);
            try {
                e.sort(this._ascending)
            } catch (s) {
                return ot(this, xt)
            }
            var n = e.reduce(function(s, u) {
                return s ? s.concat([
                    [s[s.length - 1][1], u]
                ]) : [
                    [-1 / 0, u]
                ]
            }, null);
            return n.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(n, {
                includeLowers: !1,
                includeUppers: !1
            })
        }, Ue.prototype.inAnyRange = function(C, n) {
            var s = this,
                u = this._cmp,
                l = this._ascending,
                d = this._descending,
                h = this._min,
                y = this._max;
            if (C.length === 0) return un(this);
            if (!C.every(function(I) {
                    return I[0] !== void 0 && I[1] !== void 0 && l(I[0], I[1]) <= 0
                })) return ot(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", F.InvalidArgument);
            var R = !n || n.includeLowers !== !1,
                w = n && n.includeUppers === !0,
                k, b = l;

            function P(I, N) {
                return b(I[0], N[0])
            }
            try {
                (k = C.reduce(function(I, N) {
                    for (var D = 0, U = I.length; D < U; ++D) {
                        var G = I[D];
                        if (u(N[0], G[1]) < 0 && 0 < u(N[1], G[0])) {
                            G[0] = h(G[0], N[0]), G[1] = y(G[1], N[1]);
                            break
                        }
                    }
                    return D === U && I.push(N), I
                }, [])).sort(P)
            } catch (I) {
                return ot(this, xt)
            }
            var E = 0,
                S = w ? function(I) {
                    return 0 < l(I, k[E][1])
                } : function(I) {
                    return 0 <= l(I, k[E][1])
                },
                x = R ? function(I) {
                    return 0 < d(I, k[E][0])
                } : function(I) {
                    return 0 <= d(I, k[E][0])
                },
                O = S,
                C = new this.Collection(this, function() {
                    return Dt(k[0][0], k[k.length - 1][1], !R, !w)
                });
            return C._ondirectionchange = function(I) {
                b = I === "next" ? (O = S, l) : (O = x, d), k.sort(P)
            }, C._addAlgorithm(function(I, N, D) {
                for (var U, G = I.key; O(G);)
                    if (++E === k.length) return N(D), !1;
                return !S(U = G) && !x(U) || (s._cmp(G, k[E][1]) === 0 || s._cmp(G, k[E][0]) === 0 || N(function() {
                    b === l ? I.continue(k[E][0]) : I.continue(k[E][1])
                }), !1)
            }), C
        }, Ue.prototype.startsWithAnyOf = function() {
            var e = $e.apply(at, arguments);
            return e.every(function(n) {
                return typeof n == "string"
            }) ? e.length === 0 ? un(this) : this.inAnyRange(e.map(function(n) {
                return [n, n + Gt]
            })) : ot(this, "startsWithAnyOf() only works with strings")
        }, Ue);

        function Ue() {}

        function Rt(e) {
            return xe(function(n) {
                return Tn(n), e(n.target.error), !1
            })
        }

        function Tn(e) {
            e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault()
        }
        var Cn = "storagemutated",
            Qr = "x-storagemutated-1",
            Mt = kn(null, Cn),
            ou = (Ot.prototype._lock = function() {
                return ye(!ee.global), ++this._reculock, this._reculock !== 1 || ee.global || (ee.lockOwnerFor = this), this
            }, Ot.prototype._unlock = function() {
                if (ye(!ee.global), --this._reculock == 0)
                    for (ee.global || (ee.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked();) {
                        var e = this._blockedFuncs.shift();
                        try {
                            zt(e[1], e[0])
                        } catch (n) {}
                    }
                return this
            }, Ot.prototype._locked = function() {
                return this._reculock && ee.lockOwnerFor !== this
            }, Ot.prototype.create = function(e) {
                var n = this;
                if (!this.mode) return this;
                var s = this.db.idbdb,
                    u = this.db._state.dbOpenError;
                if (ye(!this.idbtrans), !e && !s) switch (u && u.name) {
                    case "DatabaseClosedError":
                        throw new F.DatabaseClosed(u);
                    case "MissingAPIError":
                        throw new F.MissingAPI(u.message, u);
                    default:
                        throw new F.OpenFailed(u)
                }
                if (!this.active) throw new F.TransactionInactive;
                return ye(this._completion._state === null), (e = this.idbtrans = e || (this.db.core || s).transaction(this.storeNames, this.mode, {
                    durability: this.chromeTransactionDurability
                })).onerror = xe(function(l) {
                    Tn(l), n._reject(e.error)
                }), e.onabort = xe(function(l) {
                    Tn(l), n.active && n._reject(new F.Abort(e.error)), n.active = !1, n.on("abort").fire(l)
                }), e.oncomplete = xe(function() {
                    n.active = !1, n._resolve(), "mutatedParts" in e && Mt.storagemutated.fire(e.mutatedParts)
                }), this
            }, Ot.prototype._promise = function(e, n, s) {
                var u = this;
                if (e === "readwrite" && this.mode !== "readwrite") return Ie(new F.ReadOnly("Transaction is readonly"));
                if (!this.active) return Ie(new F.TransactionInactive);
                if (this._locked()) return new J(function(d, h) {
                    u._blockedFuncs.push([function() {
                        u._promise(e, n, s).then(d, h)
                    }, ee])
                });
                if (s) return Nt(function() {
                    var d = new J(function(h, y) {
                        u._lock();
                        var R = n(h, y, u);
                        R && R.then && R.then(h, y)
                    });
                    return d.finally(function() {
                        return u._unlock()
                    }), d._lib = !0, d
                });
                var l = new J(function(d, h) {
                    var y = n(d, h, u);
                    y && y.then && y.then(d, h)
                });
                return l._lib = !0, l
            }, Ot.prototype._root = function() {
                return this.parent ? this.parent._root() : this
            }, Ot.prototype.waitFor = function(e) {
                var n, s = this._root(),
                    u = J.resolve(e);
                s._waitingFor ? s._waitingFor = s._waitingFor.then(function() {
                    return u
                }) : (s._waitingFor = u, s._waitingQueue = [], n = s.idbtrans.objectStore(s.storeNames[0]), function d() {
                    for (++s._spinCount; s._waitingQueue.length;) s._waitingQueue.shift()();
                    s._waitingFor && (n.get(-1 / 0).onsuccess = d)
                }());
                var l = s._waitingFor;
                return new J(function(d, h) {
                    u.then(function(y) {
                        return s._waitingQueue.push(xe(d.bind(null, y)))
                    }, function(y) {
                        return s._waitingQueue.push(xe(h.bind(null, y)))
                    }).finally(function() {
                        s._waitingFor === l && (s._waitingFor = null)
                    })
                })
            }, Ot.prototype.abort = function() {
                this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new F.Abort))
            }, Ot.prototype.table = function(e) {
                var n = this._memoizedTables || (this._memoizedTables = {});
                if (_(n, e)) return n[e];
                var s = this.schema[e];
                if (!s) throw new F.NotFound("Table " + e + " not part of transaction");
                return s = new this.db.Table(e, s, this), s.core = this.db.core.table(e), n[e] = s
            }, Ot);

        function Ot() {}

        function Zr(e, n, s, u, l, d, h) {
            return {
                name: e,
                keyPath: n,
                unique: s,
                multi: u,
                auto: l,
                compound: d,
                src: (s && !h ? "&" : "") + (u ? "*" : "") + (l ? "++" : "") + Sa(n)
            }
        }

        function Sa(e) {
            return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : ""
        }

        function eo(e, n, s) {
            return {
                name: e,
                primKey: n,
                indexes: s,
                mappedClass: null,
                idxByName: (u = function(l) {
                    return [l.name, l]
                }, s.reduce(function(l, d, h) {
                    return h = u(d, h), h && (l[h[0]] = h[1]), l
                }, {}))
            };
            var u
        }
        var An = function(e) {
            try {
                return e.only([
                    []
                ]), An = function() {
                    return [
                        []
                    ]
                }, [
                    []
                ]
            } catch (n) {
                return An = function() {
                    return Gt
                }, Gt
            }
        };

        function to(e) {
            return e == null ? function() {} : typeof e == "string" ? (n = e).split(".").length === 1 ? function(s) {
                return s[n]
            } : function(s) {
                return me(s, n)
            } : function(s) {
                return me(s, e)
            };
            var n
        }

        function ka(e) {
            return [].slice.call(e)
        }
        var au = 0;

        function In(e) {
            return e == null ? ":id" : typeof e == "string" ? e : "[".concat(e.join("+"), "]")
        }

        function su(e, n, R) {
            function u(O) {
                if (O.type === 3) return null;
                if (O.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
                var E = O.lower,
                    S = O.upper,
                    x = O.lowerOpen,
                    O = O.upperOpen;
                return E === void 0 ? S === void 0 ? null : n.upperBound(S, !!O) : S === void 0 ? n.lowerBound(E, !!x) : n.bound(E, S, !!x, !!O)
            }

            function l(P) {
                var E, S = P.name;
                return {
                    name: S,
                    schema: P,
                    mutate: function(x) {
                        var O = x.trans,
                            C = x.type,
                            I = x.keys,
                            N = x.values,
                            D = x.range;
                        return new Promise(function(U, G) {
                            U = xe(U);
                            var H = O.objectStore(S),
                                W = H.keyPath == null,
                                Y = C === "put" || C === "add";
                            if (!Y && C !== "delete" && C !== "deleteRange") throw new Error("Invalid operation type: " + C);
                            var $, ue = (I || N || {
                                length: 1
                            }).length;
                            if (I && N && I.length !== N.length) throw new Error("Given keys array must have same length as given values array.");
                            if (ue === 0) return U({
                                numFailures: 0,
                                failures: {},
                                results: [],
                                lastResult: void 0
                            });

                            function ce(Qe) {
                                ++ht, Tn(Qe)
                            }
                            var pe = [],
                                de = [],
                                ht = 0;
                            if (C === "deleteRange") {
                                if (D.type === 4) return U({
                                    numFailures: ht,
                                    failures: de,
                                    results: [],
                                    lastResult: void 0
                                });
                                D.type === 3 ? pe.push($ = H.clear()) : pe.push($ = H.delete(u(D)))
                            } else {
                                var W = Y ? W ? [N, I] : [N, null] : [I, null],
                                    he = W[0],
                                    Ye = W[1];
                                if (Y)
                                    for (var Je = 0; Je < ue; ++Je) pe.push($ = Ye && Ye[Je] !== void 0 ? H[C](he[Je], Ye[Je]) : H[C](he[Je])), $.onerror = ce;
                                else
                                    for (Je = 0; Je < ue; ++Je) pe.push($ = H[C](he[Je])), $.onerror = ce
                            }

                            function br(Qe) {
                                Qe = Qe.target.result, pe.forEach(function(Qt, wo) {
                                    return Qt.error != null && (de[wo] = Qt.error)
                                }), U({
                                    numFailures: ht,
                                    failures: de,
                                    results: C === "delete" ? I : pe.map(function(Qt) {
                                        return Qt.result
                                    }),
                                    lastResult: Qe
                                })
                            }
                            $.onerror = function(Qe) {
                                ce(Qe), br(Qe)
                            }, $.onsuccess = br
                        })
                    },
                    getMany: function(x) {
                        var O = x.trans,
                            C = x.keys;
                        return new Promise(function(I, N) {
                            I = xe(I);
                            for (var D, U = O.objectStore(S), G = C.length, H = new Array(G), W = 0, Y = 0, $ = function(pe) {
                                    pe = pe.target, H[pe._pos] = pe.result, ++Y === W && I(H)
                                }, ue = Rt(N), ce = 0; ce < G; ++ce) C[ce] != null && ((D = U.get(C[ce]))._pos = ce, D.onsuccess = $, D.onerror = ue, ++W);
                            W === 0 && I(H)
                        })
                    },
                    get: function(x) {
                        var O = x.trans,
                            C = x.key;
                        return new Promise(function(I, N) {
                            I = xe(I);
                            var D = O.objectStore(S).get(C);
                            D.onsuccess = function(U) {
                                return I(U.target.result)
                            }, D.onerror = Rt(N)
                        })
                    },
                    query: (E = w, function(x) {
                        return new Promise(function(O, C) {
                            O = xe(O);
                            var I, N, D, W = x.trans,
                                U = x.values,
                                G = x.limit,
                                $ = x.query,
                                H = G === 1 / 0 ? void 0 : G,
                                Y = $.index,
                                $ = $.range,
                                W = W.objectStore(S),
                                Y = Y.isPrimaryKey ? W : W.index(Y.name),
                                $ = u($);
                            if (G === 0) return O({
                                result: []
                            });
                            E ? ((H = U ? Y.getAll($, H) : Y.getAllKeys($, H)).onsuccess = function(ue) {
                                return O({
                                    result: ue.target.result
                                })
                            }, H.onerror = Rt(C)) : (I = 0, N = !U && "openKeyCursor" in Y ? Y.openKeyCursor($) : Y.openCursor($), D = [], N.onsuccess = function(ue) {
                                var ce = N.result;
                                return ce ? (D.push(U ? ce.value : ce.primaryKey), ++I === G ? O({
                                    result: D
                                }) : void ce.continue()) : O({
                                    result: D
                                })
                            }, N.onerror = Rt(C))
                        })
                    }),
                    openCursor: function(x) {
                        var O = x.trans,
                            C = x.values,
                            I = x.query,
                            N = x.reverse,
                            D = x.unique;
                        return new Promise(function(U, G) {
                            U = xe(U);
                            var Y = I.index,
                                H = I.range,
                                W = O.objectStore(S),
                                W = Y.isPrimaryKey ? W : W.index(Y.name),
                                Y = N ? D ? "prevunique" : "prev" : D ? "nextunique" : "next",
                                $ = !C && "openKeyCursor" in W ? W.openKeyCursor(u(H), Y) : W.openCursor(u(H), Y);
                            $.onerror = Rt(G), $.onsuccess = xe(function(ue) {
                                var ce, pe, de, ht, he = $.result;
                                he ? (he.___id = ++au, he.done = !1, ce = he.continue.bind(he), pe = (pe = he.continuePrimaryKey) && pe.bind(he), de = he.advance.bind(he), ht = function() {
                                    throw new Error("Cursor not stopped")
                                }, he.trans = O, he.stop = he.continue = he.continuePrimaryKey = he.advance = function() {
                                    throw new Error("Cursor not started")
                                }, he.fail = xe(G), he.next = function() {
                                    var Ye = this,
                                        Je = 1;
                                    return this.start(function() {
                                        return Je-- ? Ye.continue() : Ye.stop()
                                    }).then(function() {
                                        return Ye
                                    })
                                }, he.start = function(Ye) {
                                    function Je() {
                                        if ($.result) try {
                                            Ye()
                                        } catch (Qe) {
                                            he.fail(Qe)
                                        } else he.done = !0, he.start = function() {
                                            throw new Error("Cursor behind last entry")
                                        }, he.stop()
                                    }
                                    var br = new Promise(function(Qe, Qt) {
                                        Qe = xe(Qe), $.onerror = Rt(Qt), he.fail = Qt, he.stop = function(wo) {
                                            he.stop = he.continue = he.continuePrimaryKey = he.advance = ht, Qe(wo)
                                        }
                                    });
                                    return $.onsuccess = xe(function(Qe) {
                                        $.onsuccess = Je, Je()
                                    }), he.continue = ce, he.continuePrimaryKey = pe, he.advance = de, Je(), br
                                }, U(he)) : U(null)
                            }, G)
                        })
                    },
                    count: function(x) {
                        var O = x.query,
                            C = x.trans,
                            I = O.index,
                            N = O.range;
                        return new Promise(function(D, U) {
                            var G = C.objectStore(S),
                                H = I.isPrimaryKey ? G : G.index(I.name),
                                G = u(N),
                                H = G ? H.count(G) : H.count();
                            H.onsuccess = xe(function(W) {
                                return D(W.target.result)
                            }), H.onerror = Rt(U)
                        })
                    }
                }
            }
            var d, h, y, k = (h = R, y = ka((d = e).objectStoreNames), {
                    schema: {
                        name: d.name,
                        tables: y.map(function(P) {
                            return h.objectStore(P)
                        }).map(function(P) {
                            var E = P.keyPath,
                                O = P.autoIncrement,
                                S = p(E),
                                x = {},
                                O = {
                                    name: P.name,
                                    primaryKey: {
                                        name: null,
                                        isPrimaryKey: !0,
                                        outbound: E == null,
                                        compound: S,
                                        keyPath: E,
                                        autoIncrement: O,
                                        unique: !0,
                                        extractKey: to(E)
                                    },
                                    indexes: ka(P.indexNames).map(function(C) {
                                        return P.index(C)
                                    }).map(function(D) {
                                        var I = D.name,
                                            N = D.unique,
                                            U = D.multiEntry,
                                            D = D.keyPath,
                                            U = {
                                                name: I,
                                                compound: p(D),
                                                keyPath: D,
                                                unique: N,
                                                multiEntry: U,
                                                extractKey: to(D)
                                            };
                                        return x[In(D)] = U
                                    }),
                                    getIndexByKeyPath: function(C) {
                                        return x[In(C)]
                                    }
                                };
                            return x[":id"] = O.primaryKey, E != null && (x[In(E)] = O.primaryKey), O
                        })
                    },
                    hasGetAll: 0 < y.length && "getAll" in h.objectStore(y[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
                }),
                R = k.schema,
                w = k.hasGetAll,
                k = R.tables.map(l),
                b = {};
            return k.forEach(function(P) {
                return b[P.name] = P
            }), {
                stack: "dbcore",
                transaction: e.transaction.bind(e),
                table: function(P) {
                    if (!b[P]) throw new Error("Table '".concat(P, "' not found"));
                    return b[P]
                },
                MIN_KEY: -1 / 0,
                MAX_KEY: An(n),
                schema: R
            }
        }

        function iu(e, n, s, u) {
            var l = s.IDBKeyRange;
            return s.indexedDB, {
                dbcore: (u = su(n, l, u), e.dbcore.reduce(function(d, h) {
                    return h = h.create, a(a({}, d), h(d))
                }, u))
            }
        }

        function ir(e, u) {
            var s = u.db,
                u = iu(e._middlewares, s, e._deps, u);
            e.core = u.dbcore, e.tables.forEach(function(l) {
                var d = l.name;
                e.core.schema.tables.some(function(h) {
                    return h.name === d
                }) && (l.core = e.core.table(d), e[d] instanceof e.Table && (e[d].core = l.core))
            })
        }

        function ur(e, n, s, u) {
            s.forEach(function(l) {
                var d = u[l];
                n.forEach(function(h) {
                    var y = function R(w, k) {
                        return re(w, k) || (w = v(w)) && R(w, k)
                    }(h, l);
                    (!y || "value" in y && y.value === void 0) && (h === e.Transaction.prototype || h instanceof e.Transaction ? B(h, l, {
                        get: function() {
                            return this.table(l)
                        },
                        set: function(R) {
                            A(this, l, {
                                value: R,
                                writable: !0,
                                configurable: !0,
                                enumerable: !0
                            })
                        }
                    }) : h[l] = new e.Table(l, d))
                })
            })
        }

        function no(e, n) {
            n.forEach(function(s) {
                for (var u in s) s[u] instanceof e.Table && delete s[u]
            })
        }

        function uu(e, n) {
            return e._cfg.version - n._cfg.version
        }

        function cu(e, n, s, u) {
            var l = e._dbSchema;
            s.objectStoreNames.contains("$meta") && !l.$meta && (l.$meta = eo("$meta", xa("")[0], []), e._storeNames.push("$meta"));
            var d = e._createTransaction("readwrite", e._storeNames, l);
            d.create(s), d._completion.catch(u);
            var h = d._reject.bind(d),
                y = ee.transless || ee;
            Nt(function() {
                return ee.trans = d, ee.transless = y, n !== 0 ? (ir(e, s), w = n, ((R = d).storeNames.includes("$meta") ? R.table("$meta").get("version").then(function(k) {
                    return k != null ? k : w
                }) : J.resolve(w)).then(function(k) {
                    return P = k, E = d, S = s, x = [], k = (b = e)._versions, O = b._dbSchema = lr(0, b.idbdb, S), (k = k.filter(function(C) {
                        return C._cfg.version >= P
                    })).length !== 0 ? (k.forEach(function(C) {
                        x.push(function() {
                            var I = O,
                                N = C._cfg.dbschema;
                            fr(b, I, S), fr(b, N, S), O = b._dbSchema = N;
                            var D = ro(I, N);
                            D.add.forEach(function(Y) {
                                oo(S, Y[0], Y[1].primKey, Y[1].indexes)
                            }), D.change.forEach(function(Y) {
                                if (Y.recreate) throw new F.Upgrade("Not yet support for changing primary key");
                                var $ = S.objectStore(Y.name);
                                Y.add.forEach(function(ue) {
                                    return cr($, ue)
                                }), Y.change.forEach(function(ue) {
                                    $.deleteIndex(ue.name), cr($, ue)
                                }), Y.del.forEach(function(ue) {
                                    return $.deleteIndex(ue)
                                })
                            });
                            var U = C._cfg.contentUpgrade;
                            if (U && C._cfg.version > P) {
                                ir(b, S), E._memoizedTables = {};
                                var G = fe(N);
                                D.del.forEach(function(Y) {
                                    G[Y] = I[Y]
                                }), no(b, [b.Transaction.prototype]), ur(b, [b.Transaction.prototype], f(G), G), E.schema = G;
                                var H, W = ze(U);
                                return W && on(), D = J.follow(function() {
                                    var Y;
                                    (H = U(E)) && W && (Y = Lt.bind(null, null), H.then(Y, Y))
                                }), H && typeof H.then == "function" ? J.resolve(H) : D.then(function() {
                                    return H
                                })
                            }
                        }), x.push(function(I) {
                            var N, D, U = C._cfg.dbschema;
                            N = U, D = I, [].slice.call(D.db.objectStoreNames).forEach(function(G) {
                                return N[G] == null && D.db.deleteObjectStore(G)
                            }), no(b, [b.Transaction.prototype]), ur(b, [b.Transaction.prototype], b._storeNames, b._dbSchema), E.schema = b._dbSchema
                        }), x.push(function(I) {
                            b.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(b.idbdb.version / 10) === C._cfg.version ? (b.idbdb.deleteObjectStore("$meta"), delete b._dbSchema.$meta, b._storeNames = b._storeNames.filter(function(N) {
                                return N !== "$meta"
                            })) : I.objectStore("$meta").put(C._cfg.version, "version"))
                        })
                    }), function C() {
                        return x.length ? J.resolve(x.shift()(E.idbtrans)).then(C) : J.resolve()
                    }().then(function() {
                        Pa(O, S)
                    })) : J.resolve();
                    var b, P, E, S, x, O
                }).catch(h)) : (f(l).forEach(function(k) {
                    oo(s, k, l[k].primKey, l[k].indexes)
                }), ir(e, s), void J.follow(function() {
                    return e.on.populate.fire(d)
                }).catch(h));
                var R, w
            })
        }

        function lu(e, n) {
            Pa(e._dbSchema, n), n.db.version % 10 != 0 || n.objectStoreNames.contains("$meta") || n.db.createObjectStore("$meta").add(Math.ceil(n.db.version / 10 - 1), "version");
            var s = lr(0, e.idbdb, n);
            fr(e, e._dbSchema, n);
            for (var u = 0, l = ro(s, e._dbSchema).change; u < l.length; u++) {
                var d = function(h) {
                    if (h.change.length || h.recreate) return console.warn("Unable to patch indexes of table ".concat(h.name, " because it has changes on the type of index or primary key.")), {
                        value: void 0
                    };
                    var y = n.objectStore(h.name);
                    h.add.forEach(function(R) {
                        st && console.debug("Dexie upgrade patch: Creating missing index ".concat(h.name, ".").concat(R.src)), cr(y, R)
                    })
                }(l[u]);
                if (typeof d == "object") return d.value
            }
        }

        function ro(e, n) {
            var s, u = {
                del: [],
                add: [],
                change: []
            };
            for (s in e) n[s] || u.del.push(s);
            for (s in n) {
                var l = e[s],
                    d = n[s];
                if (l) {
                    var h = {
                        name: s,
                        def: d,
                        recreate: !1,
                        del: [],
                        add: [],
                        change: []
                    };
                    if ("" + (l.primKey.keyPath || "") != "" + (d.primKey.keyPath || "") || l.primKey.auto !== d.primKey.auto) h.recreate = !0, u.change.push(h);
                    else {
                        var y = l.idxByName,
                            R = d.idxByName,
                            w = void 0;
                        for (w in y) R[w] || h.del.push(w);
                        for (w in R) {
                            var k = y[w],
                                b = R[w];
                            k ? k.src !== b.src && h.change.push(b) : h.add.push(b)
                        }(0 < h.del.length || 0 < h.add.length || 0 < h.change.length) && u.change.push(h)
                    }
                } else u.add.push([s, d])
            }
            return u
        }

        function oo(e, n, s, u) {
            var l = e.db.createObjectStore(n, s.keyPath ? {
                keyPath: s.keyPath,
                autoIncrement: s.auto
            } : {
                autoIncrement: s.auto
            });
            return u.forEach(function(d) {
                return cr(l, d)
            }), l
        }

        function Pa(e, n) {
            f(e).forEach(function(s) {
                n.db.objectStoreNames.contains(s) || (st && console.debug("Dexie: Creating missing table", s), oo(n, s, e[s].primKey, e[s].indexes))
            })
        }

        function cr(e, n) {
            e.createIndex(n.name, n.keyPath, {
                unique: n.unique,
                multiEntry: n.multi
            })
        }

        function lr(e, n, s) {
            var u = {};
            return te(n.objectStoreNames, 0).forEach(function(l) {
                for (var d = s.objectStore(l), h = Zr(Sa(w = d.keyPath), w || "", !0, !1, !!d.autoIncrement, w && typeof w != "string", !0), y = [], R = 0; R < d.indexNames.length; ++R) {
                    var k = d.index(d.indexNames[R]),
                        w = k.keyPath,
                        k = Zr(k.name, w, !!k.unique, !!k.multiEntry, !1, w && typeof w != "string", !1);
                    y.push(k)
                }
                u[l] = eo(l, h, y)
            }), u
        }

        function fr(e, n, s) {
            for (var u = s.db.objectStoreNames, l = 0; l < u.length; ++l) {
                var d = u[l],
                    h = s.objectStore(d);
                e._hasGetAll = "getAll" in h;
                for (var y = 0; y < h.indexNames.length; ++y) {
                    var R = h.indexNames[y],
                        w = h.index(R).keyPath,
                        k = typeof w == "string" ? w : "[" + te(w).join("+") + "]";
                    !n[d] || (w = n[d].idxByName[k]) && (w.name = R, delete n[d].idxByName[k], n[d].idxByName[R] = w)
                }
            }
            typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && i.WorkerGlobalScope && i instanceof i.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e._hasGetAll = !1)
        }

        function xa(e) {
            return e.split(",").map(function(n, s) {
                var u = (n = n.trim()).replace(/([&*]|\+\+)/g, ""),
                    l = /^\[/.test(u) ? u.match(/^\[(.*)\]$/)[1].split("+") : u;
                return Zr(u, l || null, /\&/.test(n), /\*/.test(n), /\+\+/.test(n), p(l), s === 0)
            })
        }
        var fu = (dr.prototype._parseStoresSpec = function(e, n) {
            f(e).forEach(function(s) {
                if (e[s] !== null) {
                    var u = xa(e[s]),
                        l = u.shift();
                    if (l.unique = !0, l.multi) throw new F.Schema("Primary key cannot be multi-valued");
                    u.forEach(function(d) {
                        if (d.auto) throw new F.Schema("Only primary key can be marked as autoIncrement (++)");
                        if (!d.keyPath) throw new F.Schema("Index must have a name and cannot be an empty string")
                    }), n[s] = eo(s, l, u)
                }
            })
        }, dr.prototype.stores = function(s) {
            var n = this.db;
            this._cfg.storesSource = this._cfg.storesSource ? m(this._cfg.storesSource, s) : s;
            var s = n._versions,
                u = {},
                l = {};
            return s.forEach(function(d) {
                m(u, d._cfg.storesSource), l = d._cfg.dbschema = {}, d._parseStoresSpec(u, l)
            }), n._dbSchema = l, no(n, [n._allTables, n, n.Transaction.prototype]), ur(n, [n._allTables, n, n.Transaction.prototype, this._cfg.tables], f(l), l), n._storeNames = f(l), this
        }, dr.prototype.upgrade = function(e) {
            return this._cfg.contentUpgrade = Rn(this._cfg.contentUpgrade || ae, e), this
        }, dr);

        function dr() {}

        function ao(e, n) {
            var s = e._dbNamesDB;
            return s || (s = e._dbNamesDB = new Ct(nr, {
                addons: [],
                indexedDB: e,
                IDBKeyRange: n
            })).version(1).stores({
                dbnames: "name"
            }), s.table("dbnames")
        }

        function so(e) {
            return e && typeof e.databases == "function"
        }

        function io(e) {
            return Nt(function() {
                return ee.letThrough = !0, e()
            })
        }

        function uo(e) {
            return !("from" in e)
        }
        var Ge = function(e, n) {
            if (!this) {
                var s = new Ge;
                return e && "d" in e && m(s, e), s
            }
            m(this, arguments.length ? {
                d: 1,
                from: e,
                to: 1 < arguments.length ? n : e
            } : {
                d: 0
            })
        };

        function Nn(e, n, s) {
            var u = we(n, s);
            if (!isNaN(u)) {
                if (0 < u) throw RangeError();
                if (uo(e)) return m(e, {
                    from: n,
                    to: s,
                    d: 1
                });
                var l = e.l,
                    u = e.r;
                if (we(s, e.from) < 0) return l ? Nn(l, n, s) : e.l = {
                    from: n,
                    to: s,
                    d: 1,
                    l: null,
                    r: null
                }, Ta(e);
                if (0 < we(n, e.to)) return u ? Nn(u, n, s) : e.r = {
                    from: n,
                    to: s,
                    d: 1,
                    l: null,
                    r: null
                }, Ta(e);
                we(n, e.from) < 0 && (e.from = n, e.l = null, e.d = u ? u.d + 1 : 1), 0 < we(s, e.to) && (e.to = s, e.r = null, e.d = e.l ? e.l.d + 1 : 1), s = !e.r, l && !e.l && Ln(e, l), u && s && Ln(e, u)
            }
        }

        function Ln(e, n) {
            uo(n) || function s(u, R) {
                var d = R.from,
                    h = R.to,
                    y = R.l,
                    R = R.r;
                Nn(u, d, h), y && s(u, y), R && s(u, R)
            }(e, n)
        }

        function hr(e, n) {
            var s = co(n),
                u = s.next();
            if (u.done) return !1;
            for (var l = u.value, d = co(e), h = d.next(l.from), y = h.value; !u.done && !h.done;) {
                if (we(y.from, l.to) <= 0 && 0 <= we(y.to, l.from)) return !0;
                we(l.from, y.from) < 0 ? l = (u = s.next(y.from)).value : y = (h = d.next(l.from)).value
            }
            return !1
        }

        function co(e) {
            var n = uo(e) ? null : {
                s: 0,
                n: e
            };
            return {
                next: function(s) {
                    for (var u = 0 < arguments.length; n;) switch (n.s) {
                        case 0:
                            if (n.s = 1, u)
                                for (; n.n.l && we(s, n.n.from) < 0;) n = {
                                    up: n,
                                    n: n.n.l,
                                    s: 1
                                };
                            else
                                for (; n.n.l;) n = {
                                    up: n,
                                    n: n.n.l,
                                    s: 1
                                };
                        case 1:
                            if (n.s = 2, !u || we(s, n.n.to) <= 0) return {
                                value: n.n,
                                done: !1
                            };
                        case 2:
                            if (n.n.r) {
                                n.s = 3, n = {
                                    up: n,
                                    n: n.n.r,
                                    s: 0
                                };
                                continue
                            }
                        case 3:
                            n = n.up
                    }
                    return {
                        done: !0
                    }
                }
            }
        }

        function Ta(e) {
            var n, s, u = (((n = e.r) === null || n === void 0 ? void 0 : n.d) || 0) - (((s = e.l) === null || s === void 0 ? void 0 : s.d) || 0),
                l = 1 < u ? "r" : u < -1 ? "l" : "";
            l && (n = l == "r" ? "l" : "r", s = a({}, e), u = e[l], e.from = u.from, e.to = u.to, e[l] = u[l], s[l] = u[n], (e[n] = s).d = Ca(s)), e.d = Ca(e)
        }

        function Ca(s) {
            var n = s.r,
                s = s.l;
            return (n ? s ? Math.max(n.d, s.d) : n.d : s ? s.d : 0) + 1
        }

        function pr(e, n) {
            return f(n).forEach(function(s) {
                e[s] ? Ln(e[s], n[s]) : e[s] = function u(l) {
                    var d, h, y = {};
                    for (d in l) _(l, d) && (h = l[d], y[d] = !h || typeof h != "object" || Ve.has(h.constructor) ? h : u(h));
                    return y
                }(n[s])
            }), e
        }

        function lo(e, n) {
            return e.all || n.all || Object.keys(e).some(function(s) {
                return n[s] && hr(n[s], e[s])
            })
        }
        T(Ge.prototype, ((ut = {
            add: function(e) {
                return Ln(this, e), this
            },
            addKey: function(e) {
                return Nn(this, e, e), this
            },
            addKeys: function(e) {
                var n = this;
                return e.forEach(function(s) {
                    return Nn(n, s, s)
                }), this
            }
        })[Oe] = function() {
            return co(this)
        }, ut));
        var Jt = {},
            fo = {},
            ho = !1;

        function mr(e) {
            pr(fo, e), ho || (ho = !0, setTimeout(function() {
                ho = !1, po(fo, !(fo = {}))
            }, 0))
        }

        function po(e, n) {
            n === void 0 && (n = !1);
            var s = new Set;
            if (e.all)
                for (var u = 0, l = Object.values(Jt); u < l.length; u++) Aa(h = l[u], e, s, n);
            else
                for (var d in e) {
                    var h, y = /^idb\:\/\/(.*)\/(.*)\//.exec(d);
                    y && (d = y[1], y = y[2], (h = Jt["idb://".concat(d, "/").concat(y)]) && Aa(h, e, s, n))
                }
            s.forEach(function(R) {
                return R()
            })
        }

        function Aa(e, n, s, u) {
            for (var l = [], d = 0, h = Object.entries(e.queries.query); d < h.length; d++) {
                for (var y = h[d], R = y[0], w = [], k = 0, b = y[1]; k < b.length; k++) {
                    var P = b[k];
                    lo(n, P.obsSet) ? P.subscribers.forEach(function(O) {
                        return s.add(O)
                    }) : u && w.push(P)
                }
                u && l.push([R, w])
            }
            if (u)
                for (var E = 0, S = l; E < S.length; E++) {
                    var x = S[E],
                        R = x[0],
                        w = x[1];
                    e.queries.query[R] = w
                }
        }

        function du(e) {
            var n = e._state,
                s = e._deps.indexedDB;
            if (n.isBeingOpened || e.idbdb) return n.dbReadyPromise.then(function() {
                return n.dbOpenError ? Ie(n.dbOpenError) : e
            });
            n.isBeingOpened = !0, n.dbOpenError = null, n.openComplete = !1;
            var u = n.openCanceller,
                l = Math.round(10 * e.verno),
                d = !1;

            function h() {
                if (n.openCanceller !== u) throw new F.DatabaseClosed("db.open() was cancelled")
            }

            function y() {
                return new J(function(P, E) {
                    if (h(), !s) throw new F.MissingAPI;
                    var S = e.name,
                        x = n.autoSchema || !l ? s.open(S) : s.open(S, l);
                    if (!x) throw new F.MissingAPI;
                    x.onerror = Rt(E), x.onblocked = xe(e._fireOnBlocked), x.onupgradeneeded = xe(function(O) {
                        var C;
                        k = x.transaction, n.autoSchema && !e._options.allowEmptyDB ? (x.onerror = Tn, k.abort(), x.result.close(), (C = s.deleteDatabase(S)).onsuccess = C.onerror = xe(function() {
                            E(new F.NoSuchDatabase("Database ".concat(S, " doesnt exist")))
                        })) : (k.onerror = Rt(E), O = O.oldVersion > Math.pow(2, 62) ? 0 : O.oldVersion, b = O < 1, e.idbdb = x.result, d && lu(e, k), cu(e, O / 10, k, E))
                    }, E), x.onsuccess = xe(function() {
                        k = null;
                        var O, C, I, N, D, U = e.idbdb = x.result,
                            G = te(U.objectStoreNames);
                        if (0 < G.length) try {
                            var H = U.transaction((N = G).length === 1 ? N[0] : N, "readonly");
                            if (n.autoSchema) C = U, I = H, (O = e).verno = C.version / 10, I = O._dbSchema = lr(0, C, I), O._storeNames = te(C.objectStoreNames, 0), ur(O, [O._allTables], f(I), I);
                            else if (fr(e, e._dbSchema, H), ((D = ro(lr(0, (D = e).idbdb, H), D._dbSchema)).add.length || D.change.some(function(W) {
                                    return W.add.length || W.change.length
                                })) && !d) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), U.close(), l = U.version + 1, d = !0, P(y());
                            ir(e, H)
                        } catch (W) {}
                        an.push(e), U.onversionchange = xe(function(W) {
                            n.vcFired = !0, e.on("versionchange").fire(W)
                        }), U.onclose = xe(function(W) {
                            e.on("close").fire(W)
                        }), b && (D = e._deps, H = S, U = D.indexedDB, D = D.IDBKeyRange, so(U) || H === nr || ao(U, D).put({
                            name: H
                        }).catch(ae)), P()
                    }, E)
                }).catch(function(P) {
                    switch (P == null ? void 0 : P.name) {
                        case "UnknownError":
                            if (0 < n.PR1398_maxLoop) return n.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), y();
                            break;
                        case "VersionError":
                            if (0 < l) return l = 0, y()
                    }
                    return J.reject(P)
                })
            }
            var R, w = n.dbReadyResolve,
                k = null,
                b = !1;
            return J.race([u, (typeof navigator > "u" ? J.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(P) {
                function E() {
                    return indexedDB.databases().finally(P)
                }
                R = setInterval(E, 100), E()
            }).finally(function() {
                return clearInterval(R)
            }) : Promise.resolve()).then(y)]).then(function() {
                return h(), n.onReadyBeingFired = [], J.resolve(io(function() {
                    return e.on.ready.fire(e.vip)
                })).then(function P() {
                    if (0 < n.onReadyBeingFired.length) {
                        var E = n.onReadyBeingFired.reduce(Rn, ae);
                        return n.onReadyBeingFired = [], J.resolve(io(function() {
                            return E(e.vip)
                        })).then(P)
                    }
                })
            }).finally(function() {
                n.openCanceller === u && (n.onReadyBeingFired = null, n.isBeingOpened = !1)
            }).catch(function(P) {
                n.dbOpenError = P;
                try {
                    k && k.abort()
                } catch (E) {}
                return u === n.openCanceller && e._close(), Ie(P)
            }).finally(function() {
                n.openComplete = !0, w()
            }).then(function() {
                var P;
                return b && (P = {}, e.tables.forEach(function(E) {
                    E.schema.indexes.forEach(function(S) {
                        S.name && (P["idb://".concat(e.name, "/").concat(E.name, "/").concat(S.name)] = new Ge(-1 / 0, [
                            [
                                []
                            ]
                        ]))
                    }), P["idb://".concat(e.name, "/").concat(E.name, "/")] = P["idb://".concat(e.name, "/").concat(E.name, "/:dels")] = new Ge(-1 / 0, [
                        [
                            []
                        ]
                    ])
                }), Mt(Cn).fire(P), po(P, !0)), e
            })
        }

        function mo(e) {
            function n(d) {
                return e.next(d)
            }
            var s = l(n),
                u = l(function(d) {
                    return e.throw(d)
                });

            function l(d) {
                return function(R) {
                    var y = d(R),
                        R = y.value;
                    return y.done ? R : R && typeof R.then == "function" ? R.then(s, u) : p(R) ? Promise.all(R).then(s, u) : s(R)
                }
            }
            return l(n)()
        }

        function yr(e, n, s) {
            for (var u = p(e) ? e.slice() : [e], l = 0; l < s; ++l) u.push(n);
            return u
        }
        var hu = {
            stack: "dbcore",
            name: "VirtualIndexMiddleware",
            level: 1,
            create: function(e) {
                return a(a({}, e), {
                    table: function(n) {
                        var s = e.table(n),
                            u = s.schema,
                            l = {},
                            d = [];

                        function h(b, P, E) {
                            var S = In(b),
                                x = l[S] = l[S] || [],
                                O = b == null ? 0 : typeof b == "string" ? 1 : b.length,
                                C = 0 < P,
                                C = a(a({}, E), {
                                    name: C ? "".concat(S, "(virtual-from:").concat(E.name, ")") : E.name,
                                    lowLevelIndex: E,
                                    isVirtual: C,
                                    keyTail: P,
                                    keyLength: O,
                                    extractKey: to(b),
                                    unique: !C && E.unique
                                });
                            return x.push(C), C.isPrimaryKey || d.push(C), 1 < O && h(O === 2 ? b[0] : b.slice(0, O - 1), P + 1, E), x.sort(function(I, N) {
                                return I.keyTail - N.keyTail
                            }), C
                        }
                        n = h(u.primaryKey.keyPath, 0, u.primaryKey), l[":id"] = [n];
                        for (var y = 0, R = u.indexes; y < R.length; y++) {
                            var w = R[y];
                            h(w.keyPath, 0, w)
                        }

                        function k(b) {
                            var P, E = b.query.index;
                            return E.isVirtual ? a(a({}, b), {
                                query: {
                                    index: E.lowLevelIndex,
                                    range: (P = b.query.range, E = E.keyTail, {
                                        type: P.type === 1 ? 2 : P.type,
                                        lower: yr(P.lower, P.lowerOpen ? e.MAX_KEY : e.MIN_KEY, E),
                                        lowerOpen: !0,
                                        upper: yr(P.upper, P.upperOpen ? e.MIN_KEY : e.MAX_KEY, E),
                                        upperOpen: !0
                                    })
                                }
                            }) : b
                        }
                        return a(a({}, s), {
                            schema: a(a({}, u), {
                                primaryKey: n,
                                indexes: d,
                                getIndexByKeyPath: function(b) {
                                    return (b = l[In(b)]) && b[0]
                                }
                            }),
                            count: function(b) {
                                return s.count(k(b))
                            },
                            query: function(b) {
                                return s.query(k(b))
                            },
                            openCursor: function(b) {
                                var P = b.query.index,
                                    E = P.keyTail,
                                    S = P.isVirtual,
                                    x = P.keyLength;
                                return S ? s.openCursor(k(b)).then(function(C) {
                                    return C && O(C)
                                }) : s.openCursor(b);

                                function O(C) {
                                    return Object.create(C, {
                                        continue: {
                                            value: function(I) {
                                                I != null ? C.continue(yr(I, b.reverse ? e.MAX_KEY : e.MIN_KEY, E)) : b.unique ? C.continue(C.key.slice(0, x).concat(b.reverse ? e.MIN_KEY : e.MAX_KEY, E)) : C.continue()
                                            }
                                        },
                                        continuePrimaryKey: {
                                            value: function(I, N) {
                                                C.continuePrimaryKey(yr(I, e.MAX_KEY, E), N)
                                            }
                                        },
                                        primaryKey: {
                                            get: function() {
                                                return C.primaryKey
                                            }
                                        },
                                        key: {
                                            get: function() {
                                                var I = C.key;
                                                return x === 1 ? I[0] : I.slice(0, x)
                                            }
                                        },
                                        value: {
                                            get: function() {
                                                return C.value
                                            }
                                        }
                                    })
                                }
                            }
                        })
                    }
                })
            }
        };

        function yo(e, n, s, u) {
            return s = s || {}, u = u || "", f(e).forEach(function(l) {
                var d, h, y;
                _(n, l) ? (d = e[l], h = n[l], typeof d == "object" && typeof h == "object" && d && h ? (y = He(d)) !== He(h) ? s[u + l] = n[l] : y === "Object" ? yo(d, h, s, u + l + ".") : d !== h && (s[u + l] = n[l]) : d !== h && (s[u + l] = n[l])) : s[u + l] = void 0
            }), f(n).forEach(function(l) {
                _(e, l) || (s[u + l] = n[l])
            }), s
        }

        function go(e, n) {
            return n.type === "delete" ? n.keys : n.keys || n.values.map(e.extractKey)
        }
        var pu = {
            stack: "dbcore",
            name: "HooksMiddleware",
            level: 2,
            create: function(e) {
                return a(a({}, e), {
                    table: function(n) {
                        var s = e.table(n),
                            u = s.schema.primaryKey;
                        return a(a({}, s), {
                            mutate: function(l) {
                                var d = ee.trans,
                                    h = d.table(n).hook,
                                    y = h.deleting,
                                    R = h.creating,
                                    w = h.updating;
                                switch (l.type) {
                                    case "add":
                                        if (R.fire === ae) break;
                                        return d._promise("readwrite", function() {
                                            return k(l)
                                        }, !0);
                                    case "put":
                                        if (R.fire === ae && w.fire === ae) break;
                                        return d._promise("readwrite", function() {
                                            return k(l)
                                        }, !0);
                                    case "delete":
                                        if (y.fire === ae) break;
                                        return d._promise("readwrite", function() {
                                            return k(l)
                                        }, !0);
                                    case "deleteRange":
                                        if (y.fire === ae) break;
                                        return d._promise("readwrite", function() {
                                            return function b(P, E, S) {
                                                return s.query({
                                                    trans: P,
                                                    values: !1,
                                                    query: {
                                                        index: u,
                                                        range: E
                                                    },
                                                    limit: S
                                                }).then(function(x) {
                                                    var O = x.result;
                                                    return k({
                                                        type: "delete",
                                                        keys: O,
                                                        trans: P
                                                    }).then(function(C) {
                                                        return 0 < C.numFailures ? Promise.reject(C.failures[0]) : O.length < S ? {
                                                            failures: [],
                                                            numFailures: 0,
                                                            lastResult: void 0
                                                        } : b(P, a(a({}, E), {
                                                            lower: O[O.length - 1],
                                                            lowerOpen: !0
                                                        }), S)
                                                    })
                                                })
                                            }(l.trans, l.range, 1e4)
                                        }, !0)
                                }
                                return s.mutate(l);

                                function k(b) {
                                    var P, E, S, x = ee.trans,
                                        O = b.keys || go(u, b);
                                    if (!O) throw new Error("Keys missing");
                                    return (b = b.type === "add" || b.type === "put" ? a(a({}, b), {
                                        keys: O
                                    }) : a({}, b)).type !== "delete" && (b.values = c([], b.values)), b.keys && (b.keys = c([], b.keys)), P = s, S = O, ((E = b).type === "add" ? Promise.resolve([]) : P.getMany({
                                        trans: E.trans,
                                        keys: S,
                                        cache: "immutable"
                                    })).then(function(C) {
                                        var I = O.map(function(N, D) {
                                            var U, G, H, W = C[D],
                                                Y = {
                                                    onerror: null,
                                                    onsuccess: null
                                                };
                                            return b.type === "delete" ? y.fire.call(Y, N, W, x) : b.type === "add" || W === void 0 ? (U = R.fire.call(Y, N, b.values[D], x), N == null && U != null && (b.keys[D] = N = U, u.outbound || se(b.values[D], u.keyPath, N))) : (U = yo(W, b.values[D]), (G = w.fire.call(Y, U, N, W, x)) && (H = b.values[D], Object.keys(G).forEach(function($) {
                                                _(H, $) ? H[$] = G[$] : se(H, $, G[$])
                                            }))), Y
                                        });
                                        return s.mutate(b).then(function(N) {
                                            for (var D = N.failures, U = N.results, G = N.numFailures, N = N.lastResult, H = 0; H < O.length; ++H) {
                                                var W = (U || O)[H],
                                                    Y = I[H];
                                                W == null ? Y.onerror && Y.onerror(D[H]) : Y.onsuccess && Y.onsuccess(b.type === "put" && C[H] ? b.values[H] : W)
                                            }
                                            return {
                                                failures: D,
                                                results: U,
                                                numFailures: G,
                                                lastResult: N
                                            }
                                        }).catch(function(N) {
                                            return I.forEach(function(D) {
                                                return D.onerror && D.onerror(N)
                                            }), Promise.reject(N)
                                        })
                                    })
                                }
                            }
                        })
                    }
                })
            }
        };

        function Ia(e, n, s) {
            try {
                if (!n || n.keys.length < e.length) return null;
                for (var u = [], l = 0, d = 0; l < n.keys.length && d < e.length; ++l) we(n.keys[l], e[d]) === 0 && (u.push(s ? Fe(n.values[l]) : n.values[l]), ++d);
                return u.length === e.length ? u : null
            } catch (h) {
                return null
            }
        }
        var mu = {
            stack: "dbcore",
            level: -1,
            create: function(e) {
                return {
                    table: function(n) {
                        var s = e.table(n);
                        return a(a({}, s), {
                            getMany: function(u) {
                                if (!u.cache) return s.getMany(u);
                                var l = Ia(u.keys, u.trans._cache, u.cache === "clone");
                                return l ? J.resolve(l) : s.getMany(u).then(function(d) {
                                    return u.trans._cache = {
                                        keys: u.keys,
                                        values: u.cache === "clone" ? Fe(d) : d
                                    }, d
                                })
                            },
                            mutate: function(u) {
                                return u.type !== "add" && (u.trans._cache = null), s.mutate(u)
                            }
                        })
                    }
                }
            }
        };

        function Na(e, n) {
            return e.trans.mode === "readonly" && !!e.subscr && !e.trans.explicit && e.trans.db._options.cache !== "disabled" && !n.schema.primaryKey.outbound
        }

        function La(e, n) {
            switch (e) {
                case "query":
                    return n.values && !n.unique;
                case "get":
                case "getMany":
                case "count":
                case "openCursor":
                    return !1
            }
        }
        var yu = {
            stack: "dbcore",
            level: 0,
            name: "Observability",
            create: function(e) {
                var n = e.schema.name,
                    s = new Ge(e.MIN_KEY, e.MAX_KEY);
                return a(a({}, e), {
                    transaction: function(u, l, d) {
                        if (ee.subscr && l !== "readonly") throw new F.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(ee.querier));
                        return e.transaction(u, l, d)
                    },
                    table: function(u) {
                        var l = e.table(u),
                            d = l.schema,
                            h = d.primaryKey,
                            b = d.indexes,
                            y = h.extractKey,
                            R = h.outbound,
                            w = h.autoIncrement && b.filter(function(E) {
                                return E.compound && E.keyPath.includes(h.keyPath)
                            }),
                            k = a(a({}, l), {
                                mutate: function(E) {
                                    function S($) {
                                        return $ = "idb://".concat(n, "/").concat(u, "/").concat($), N[$] || (N[$] = new Ge)
                                    }
                                    var x, O, C, I = E.trans,
                                        N = E.mutatedParts || (E.mutatedParts = {}),
                                        D = S(""),
                                        U = S(":dels"),
                                        G = E.type,
                                        Y = E.type === "deleteRange" ? [E.range] : E.type === "delete" ? [E.keys] : E.values.length < 50 ? [go(h, E).filter(function($) {
                                            return $
                                        }), E.values] : [],
                                        H = Y[0],
                                        W = Y[1],
                                        Y = E.trans._cache;
                                    return p(H) ? (D.addKeys(H), (Y = G === "delete" || H.length === W.length ? Ia(H, Y) : null) || U.addKeys(H), (Y || W) && (x = S, O = Y, C = W, d.indexes.forEach(function($) {
                                        var ue = x($.name || "");

                                        function ce(de) {
                                            return de != null ? $.extractKey(de) : null
                                        }

                                        function pe(de) {
                                            return $.multiEntry && p(de) ? de.forEach(function(ht) {
                                                return ue.addKey(ht)
                                            }) : ue.addKey(de)
                                        }(O || C).forEach(function(de, Ye) {
                                            var he = O && ce(O[Ye]),
                                                Ye = C && ce(C[Ye]);
                                            we(he, Ye) !== 0 && (he != null && pe(he), Ye != null && pe(Ye))
                                        })
                                    }))) : H ? (W = {
                                        from: H.lower,
                                        to: H.upper
                                    }, U.add(W), D.add(W)) : (D.add(s), U.add(s), d.indexes.forEach(function($) {
                                        return S($.name).add(s)
                                    })), l.mutate(E).then(function($) {
                                        return !H || E.type !== "add" && E.type !== "put" || (D.addKeys($.results), w && w.forEach(function(ue) {
                                            var ce = E.values.map(function(de) {
                                                    return ue.extractKey(de)
                                                }),
                                                pe = ue.keyPath.findIndex(function(de) {
                                                    return de === h.keyPath
                                                });
                                            $.results.forEach(function(de) {
                                                return ce[pe] = de
                                            }), S(ue.name).addKeys(ce)
                                        })), I.mutatedParts = pr(I.mutatedParts || {}, N), $
                                    })
                                }
                            }),
                            b = function(S) {
                                var x = S.query,
                                    S = x.index,
                                    x = x.range;
                                return [S, new Ge((S = x.lower) !== null && S !== void 0 ? S : e.MIN_KEY, (x = x.upper) !== null && x !== void 0 ? x : e.MAX_KEY)]
                            },
                            P = {
                                get: function(E) {
                                    return [h, new Ge(E.key)]
                                },
                                getMany: function(E) {
                                    return [h, new Ge().addKeys(E.keys)]
                                },
                                count: b,
                                query: b,
                                openCursor: b
                            };
                        return f(P).forEach(function(E) {
                            k[E] = function(S) {
                                var x = ee.subscr,
                                    O = !!x,
                                    C = Na(ee, l) && La(E, S) ? S.obsSet = {} : x;
                                if (O) {
                                    var I = function(W) {
                                            return W = "idb://".concat(n, "/").concat(u, "/").concat(W), C[W] || (C[W] = new Ge)
                                        },
                                        N = I(""),
                                        D = I(":dels"),
                                        x = P[E](S),
                                        O = x[0],
                                        x = x[1];
                                    if ((E === "query" && O.isPrimaryKey && !S.values ? D : I(O.name || "")).add(x), !O.isPrimaryKey) {
                                        if (E !== "count") {
                                            var U = E === "query" && R && S.values && l.query(a(a({}, S), {
                                                values: !1
                                            }));
                                            return l[E].apply(this, arguments).then(function(W) {
                                                if (E === "query") {
                                                    if (R && S.values) return U.then(function(ce) {
                                                        return ce = ce.result, N.addKeys(ce), W
                                                    });
                                                    var Y = S.values ? W.result.map(y) : W.result;
                                                    (S.values ? N : D).addKeys(Y)
                                                } else if (E === "openCursor") {
                                                    var $ = W,
                                                        ue = S.values;
                                                    return $ && Object.create($, {
                                                        key: {
                                                            get: function() {
                                                                return D.addKey($.primaryKey), $.key
                                                            }
                                                        },
                                                        primaryKey: {
                                                            get: function() {
                                                                var ce = $.primaryKey;
                                                                return D.addKey(ce), ce
                                                            }
                                                        },
                                                        value: {
                                                            get: function() {
                                                                return ue && N.addKey($.primaryKey), $.value
                                                            }
                                                        }
                                                    })
                                                }
                                                return W
                                            })
                                        }
                                        D.add(s)
                                    }
                                }
                                return l[E].apply(this, arguments)
                            }
                        }), k
                    }
                })
            }
        };

        function Fa(e, n, s) {
            if (s.numFailures === 0) return n;
            if (n.type === "deleteRange") return null;
            var u = n.keys ? n.keys.length : "values" in n && n.values ? n.values.length : 1;
            return s.numFailures === u ? null : (n = a({}, n), p(n.keys) && (n.keys = n.keys.filter(function(l, d) {
                return !(d in s.failures)
            })), "values" in n && p(n.values) && (n.values = n.values.filter(function(l, d) {
                return !(d in s.failures)
            })), n)
        }

        function vo(e, n) {
            return s = e, ((u = n).lower === void 0 || (u.lowerOpen ? 0 < we(s, u.lower) : 0 <= we(s, u.lower))) && (e = e, (n = n).upper === void 0 || (n.upperOpen ? we(e, n.upper) < 0 : we(e, n.upper) <= 0));
            var s, u
        }

        function Da(e, n, P, u, l, d) {
            if (!P || P.length === 0) return e;
            var h = n.query.index,
                y = h.multiEntry,
                R = n.query.range,
                w = u.schema.primaryKey.extractKey,
                k = h.extractKey,
                b = (h.lowLevelIndex || h).extractKey,
                P = P.reduce(function(E, S) {
                    var x = E,
                        O = S.type === "add" || S.type === "put" ? S.values.filter(function(D) {
                            return D = k(D), y && p(D) ? D.some(function(U) {
                                return vo(U, R)
                            }) : vo(D, R)
                        }).map(function(D) {
                            return D = Fe(D), d && Object.freeze(D), D
                        }) : [];
                    switch (S.type) {
                        case "add":
                            x = E.concat(n.values ? O : O.map(function(U) {
                                return w(U)
                            }));
                            break;
                        case "put":
                            var C = new Ge().addKeys(S.values.map(function(U) {
                                    return w(U)
                                })),
                                x = E.filter(function(U) {
                                    return U = n.values ? w(U) : U, !hr(new Ge(U), C)
                                }).concat(n.values ? O : O.map(function(U) {
                                    return w(U)
                                }));
                            break;
                        case "delete":
                            var I = new Ge().addKeys(S.keys);
                            x = E.filter(function(U) {
                                return U = n.values ? w(U) : U, !hr(new Ge(U), I)
                            });
                            break;
                        case "deleteRange":
                            var N = S.range;
                            x = E.filter(function(U) {
                                return !vo(w(U), N)
                            })
                    }
                    return x
                }, e);
            return P === e ? e : (P.sort(function(E, S) {
                return we(b(E), b(S)) || we(w(E), w(S))
            }), n.limit && n.limit < 1 / 0 && (P.length > n.limit ? P.length = n.limit : e.length === n.limit && P.length < n.limit && (l.dirty = !0)), d ? Object.freeze(P) : P)
        }

        function Ma(e, n) {
            return we(e.lower, n.lower) === 0 && we(e.upper, n.upper) === 0 && !!e.lowerOpen == !!n.lowerOpen && !!e.upperOpen == !!n.upperOpen
        }

        function gu(e, n) {
            return function(s, u, l, d) {
                if (s === void 0) return u !== void 0 ? -1 : 0;
                if (u === void 0) return 1;
                if ((u = we(s, u)) === 0) {
                    if (l && d) return 0;
                    if (l) return 1;
                    if (d) return -1
                }
                return u
            }(e.lower, n.lower, e.lowerOpen, n.lowerOpen) <= 0 && 0 <= function(s, u, l, d) {
                if (s === void 0) return u !== void 0 ? 1 : 0;
                if (u === void 0) return -1;
                if ((u = we(s, u)) === 0) {
                    if (l && d) return 0;
                    if (l) return -1;
                    if (d) return 1
                }
                return u
            }(e.upper, n.upper, e.upperOpen, n.upperOpen)
        }

        function vu(e, n, s, u) {
            e.subscribers.add(s), u.addEventListener("abort", function() {
                var l, d;
                e.subscribers.delete(s), e.subscribers.size === 0 && (l = e, d = n, setTimeout(function() {
                    l.subscribers.size === 0 && Xe(d, l)
                }, 3e3))
            })
        }
        var bu = {
            stack: "dbcore",
            level: 0,
            name: "Cache",
            create: function(e) {
                var n = e.schema.name;
                return a(a({}, e), {
                    transaction: function(s, u, l) {
                        var d, h, y = e.transaction(s, u, l);
                        return u === "readwrite" && (h = (d = new AbortController).signal, l = function(R) {
                            return function() {
                                if (d.abort(), u === "readwrite") {
                                    for (var w = new Set, k = 0, b = s; k < b.length; k++) {
                                        var P = b[k],
                                            E = Jt["idb://".concat(n, "/").concat(P)];
                                        if (E) {
                                            var S = e.table(P),
                                                x = E.optimisticOps.filter(function(ue) {
                                                    return ue.trans === y
                                                });
                                            if (y._explicit && R && y.mutatedParts)
                                                for (var O = 0, C = Object.values(E.queries.query); O < C.length; O++)
                                                    for (var I = 0, N = (G = C[O]).slice(); I < N.length; I++) lo((H = N[I]).obsSet, y.mutatedParts) && (Xe(G, H), H.subscribers.forEach(function(ue) {
                                                        return w.add(ue)
                                                    }));
                                            else if (0 < x.length) {
                                                E.optimisticOps = E.optimisticOps.filter(function(ue) {
                                                    return ue.trans !== y
                                                });
                                                for (var D = 0, U = Object.values(E.queries.query); D < U.length; D++)
                                                    for (var G, H, W, Y = 0, $ = (G = U[D]).slice(); Y < $.length; Y++)(H = $[Y]).res != null && y.mutatedParts && (R && !H.dirty ? (W = Object.isFrozen(H.res), W = Da(H.res, H.req, x, S, H, W), H.dirty ? (Xe(G, H), H.subscribers.forEach(function(ue) {
                                                        return w.add(ue)
                                                    })) : W !== H.res && (H.res = W, H.promise = J.resolve({
                                                        result: W
                                                    }))) : (H.dirty && Xe(G, H), H.subscribers.forEach(function(ue) {
                                                        return w.add(ue)
                                                    })))
                                            }
                                        }
                                    }
                                    w.forEach(function(ue) {
                                        return ue()
                                    })
                                }
                            }
                        }, y.addEventListener("abort", l(!1), {
                            signal: h
                        }), y.addEventListener("error", l(!1), {
                            signal: h
                        }), y.addEventListener("complete", l(!0), {
                            signal: h
                        })), y
                    },
                    table: function(s) {
                        var u = e.table(s),
                            l = u.schema.primaryKey;
                        return a(a({}, u), {
                            mutate: function(d) {
                                var h = ee.trans;
                                if (l.outbound || h.db._options.cache === "disabled" || h.explicit) return u.mutate(d);
                                var y = Jt["idb://".concat(n, "/").concat(s)];
                                return y ? (h = u.mutate(d), d.type !== "add" && d.type !== "put" || !(50 <= d.values.length || go(l, d).some(function(R) {
                                    return R == null
                                })) ? (y.optimisticOps.push(d), d.mutatedParts && mr(d.mutatedParts), h.then(function(R) {
                                    0 < R.numFailures && (Xe(y.optimisticOps, d), (R = Fa(0, d, R)) && y.optimisticOps.push(R), d.mutatedParts && mr(d.mutatedParts))
                                }), h.catch(function() {
                                    Xe(y.optimisticOps, d), d.mutatedParts && mr(d.mutatedParts)
                                })) : h.then(function(R) {
                                    var w = Fa(0, a(a({}, d), {
                                        values: d.values.map(function(E, b) {
                                            var P, E = (P = l.keyPath) !== null && P !== void 0 && P.includes(".") ? Fe(E) : a({}, E);
                                            return se(E, l.keyPath, R.results[b]), E
                                        })
                                    }), R);
                                    y.optimisticOps.push(w), queueMicrotask(function() {
                                        return d.mutatedParts && mr(d.mutatedParts)
                                    })
                                }), h) : u.mutate(d)
                            },
                            query: function(d) {
                                if (!Na(ee, u) || !La("query", d)) return u.query(d);
                                var h = ((w = ee.trans) === null || w === void 0 ? void 0 : w.db._options.cache) === "immutable",
                                    b = ee,
                                    y = b.requery,
                                    R = b.signal,
                                    w = function(S, x, O, C) {
                                        var I = Jt["idb://".concat(S, "/").concat(x)];
                                        if (!I) return [];
                                        if (!(x = I.queries[O])) return [null, !1, I, null];
                                        var N = x[(C.query ? C.query.index.name : null) || ""];
                                        if (!N) return [null, !1, I, null];
                                        switch (O) {
                                            case "query":
                                                var D = N.find(function(U) {
                                                    return U.req.limit === C.limit && U.req.values === C.values && Ma(U.req.query.range, C.query.range)
                                                });
                                                return D ? [D, !0, I, N] : [N.find(function(U) {
                                                    return ("limit" in U.req ? U.req.limit : 1 / 0) >= C.limit && (!C.values || U.req.values) && gu(U.req.query.range, C.query.range)
                                                }), !1, I, N];
                                            case "count":
                                                return D = N.find(function(U) {
                                                    return Ma(U.req.query.range, C.query.range)
                                                }), [D, !!D, I, N]
                                        }
                                    }(n, s, "query", d),
                                    k = w[0],
                                    b = w[1],
                                    P = w[2],
                                    E = w[3];
                                return k && b ? k.obsSet = d.obsSet : (b = u.query(d).then(function(S) {
                                    var x = S.result;
                                    if (k && (k.res = x), h) {
                                        for (var O = 0, C = x.length; O < C; ++O) Object.freeze(x[O]);
                                        Object.freeze(x)
                                    } else S.result = Fe(x);
                                    return S
                                }).catch(function(S) {
                                    return E && k && Xe(E, k), Promise.reject(S)
                                }), k = {
                                    obsSet: d.obsSet,
                                    promise: b,
                                    subscribers: new Set,
                                    type: "query",
                                    req: d,
                                    dirty: !1
                                }, E ? E.push(k) : (E = [k], (P = P || (Jt["idb://".concat(n, "/").concat(s)] = {
                                    queries: {
                                        query: {},
                                        count: {}
                                    },
                                    objs: new Map,
                                    optimisticOps: [],
                                    unsignaledParts: {}
                                })).queries.query[d.query.index.name || ""] = E)), vu(k, E, y, R), k.promise.then(function(S) {
                                    return {
                                        result: Da(S.result, d, P == null ? void 0 : P.optimisticOps, u, k, h)
                                    }
                                })
                            }
                        })
                    }
                })
            }
        };

        function gr(e, n) {
            return new Proxy(e, {
                get: function(s, u, l) {
                    return u === "db" ? n : Reflect.get(s, u, l)
                }
            })
        }
        var Ct = (Ne.prototype.version = function(e) {
            if (isNaN(e) || e < .1) throw new F.Type("Given version is not a positive number");
            if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new F.Schema("Cannot add version when database is open");
            this.verno = Math.max(this.verno, e);
            var n = this._versions,
                s = n.filter(function(u) {
                    return u._cfg.version === e
                })[0];
            return s || (s = new this.Version(e), n.push(s), n.sort(uu), s.stores({}), this._state.autoSchema = !1, s)
        }, Ne.prototype._whenReady = function(e) {
            var n = this;
            return this.idbdb && (this._state.openComplete || ee.letThrough || this._vip) ? e() : new J(function(s, u) {
                if (n._state.openComplete) return u(new F.DatabaseClosed(n._state.dbOpenError));
                if (!n._state.isBeingOpened) {
                    if (!n._state.autoOpen) return void u(new F.DatabaseClosed);
                    n.open().catch(ae)
                }
                n._state.dbReadyPromise.then(s, u)
            }).then(e)
        }, Ne.prototype.use = function(e) {
            var n = e.stack,
                s = e.create,
                u = e.level,
                l = e.name;
            return l && this.unuse({
                stack: n,
                name: l
            }), e = this._middlewares[n] || (this._middlewares[n] = []), e.push({
                stack: n,
                create: s,
                level: u == null ? 10 : u,
                name: l
            }), e.sort(function(d, h) {
                return d.level - h.level
            }), this
        }, Ne.prototype.unuse = function(e) {
            var n = e.stack,
                s = e.name,
                u = e.create;
            return n && this._middlewares[n] && (this._middlewares[n] = this._middlewares[n].filter(function(l) {
                return u ? l.create !== u : !!s && l.name !== s
            })), this
        }, Ne.prototype.open = function() {
            var e = this;
            return zt(Pt, function() {
                return du(e)
            })
        }, Ne.prototype._close = function() {
            var e = this._state,
                n = an.indexOf(this);
            if (0 <= n && an.splice(n, 1), this.idbdb) {
                try {
                    this.idbdb.close()
                } catch (s) {}
                this.idbdb = null
            }
            e.isBeingOpened || (e.dbReadyPromise = new J(function(s) {
                e.dbReadyResolve = s
            }), e.openCanceller = new J(function(s, u) {
                e.cancelOpen = u
            }))
        }, Ne.prototype.close = function(s) {
            var n = (s === void 0 ? {
                    disableAutoOpen: !0
                } : s).disableAutoOpen,
                s = this._state;
            n ? (s.isBeingOpened && s.cancelOpen(new F.DatabaseClosed), this._close(), s.autoOpen = !1, s.dbOpenError = new F.DatabaseClosed) : (this._close(), s.autoOpen = this._options.autoOpen || s.isBeingOpened, s.openComplete = !1, s.dbOpenError = null)
        }, Ne.prototype.delete = function(e) {
            var n = this;
            e === void 0 && (e = {
                disableAutoOpen: !0
            });
            var s = 0 < arguments.length && typeof arguments[0] != "object",
                u = this._state;
            return new J(function(l, d) {
                function h() {
                    n.close(e);
                    var y = n._deps.indexedDB.deleteDatabase(n.name);
                    y.onsuccess = xe(function() {
                        var R, w, k;
                        R = n._deps, w = n.name, k = R.indexedDB, R = R.IDBKeyRange, so(k) || w === nr || ao(k, R).delete(w).catch(ae), l()
                    }), y.onerror = Rt(d), y.onblocked = n._fireOnBlocked
                }
                if (s) throw new F.InvalidArgument("Invalid closeOptions argument to db.delete()");
                u.isBeingOpened ? u.dbReadyPromise.then(h) : h()
            })
        }, Ne.prototype.backendDB = function() {
            return this.idbdb
        }, Ne.prototype.isOpen = function() {
            return this.idbdb !== null
        }, Ne.prototype.hasBeenClosed = function() {
            var e = this._state.dbOpenError;
            return e && e.name === "DatabaseClosed"
        }, Ne.prototype.hasFailed = function() {
            return this._state.dbOpenError !== null
        }, Ne.prototype.dynamicallyOpened = function() {
            return this._state.autoSchema
        }, Object.defineProperty(Ne.prototype, "tables", {
            get: function() {
                var e = this;
                return f(this._allTables).map(function(n) {
                    return e._allTables[n]
                })
            },
            enumerable: !1,
            configurable: !0
        }), Ne.prototype.transaction = function() {
            var e = (function(n, s, u) {
                var l = arguments.length;
                if (l < 2) throw new F.InvalidArgument("Too few arguments");
                for (var d = new Array(l - 1); --l;) d[l - 1] = arguments[l];
                return u = d.pop(), [n, Ae(d), u]
            }).apply(this, arguments);
            return this._transaction.apply(this, e)
        }, Ne.prototype._transaction = function(e, n, s) {
            var u = this,
                l = ee.trans;
            l && l.db === this && e.indexOf("!") === -1 || (l = null);
            var d, h, y = e.indexOf("?") !== -1;
            e = e.replace("!", "").replace("?", "");
            try {
                if (h = n.map(function(w) {
                        if (w = w instanceof u.Table ? w.name : w, typeof w != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                        return w
                    }), e == "r" || e === zr) d = zr;
                else {
                    if (e != "rw" && e != Gr) throw new F.InvalidArgument("Invalid transaction mode: " + e);
                    d = Gr
                }
                if (l) {
                    if (l.mode === zr && d === Gr) {
                        if (!y) throw new F.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                        l = null
                    }
                    l && h.forEach(function(w) {
                        if (l && l.storeNames.indexOf(w) === -1) {
                            if (!y) throw new F.SubTransaction("Table " + w + " not included in parent transaction.");
                            l = null
                        }
                    }), y && l && !l.active && (l = null)
                }
            } catch (w) {
                return l ? l._promise(null, function(k, b) {
                    b(w)
                }) : Ie(w)
            }
            var R = (function w(k, b, P, E, S) {
                return J.resolve().then(function() {
                    var x = ee.transless || ee,
                        O = k._createTransaction(b, P, k._dbSchema, E);
                    if (O.explicit = !0, x = {
                            trans: O,
                            transless: x
                        }, E) O.idbtrans = E.idbtrans;
                    else try {
                        O.create(), O.idbtrans._explicit = !0, k._state.PR1398_maxLoop = 3
                    } catch (N) {
                        return N.name === K.InvalidState && k.isOpen() && 0 < --k._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), k.close({
                            disableAutoOpen: !1
                        }), k.open().then(function() {
                            return w(k, b, P, null, S)
                        })) : Ie(N)
                    }
                    var C, I = ze(S);
                    return I && on(), x = J.follow(function() {
                        var N;
                        (C = S.call(O, O)) && (I ? (N = Lt.bind(null, null), C.then(N, N)) : typeof C.next == "function" && typeof C.throw == "function" && (C = mo(C)))
                    }, x), (C && typeof C.then == "function" ? J.resolve(C).then(function(N) {
                        return O.active ? N : Ie(new F.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))
                    }) : x.then(function() {
                        return C
                    })).then(function(N) {
                        return E && O._resolve(), O._completion.then(function() {
                            return N
                        })
                    }).catch(function(N) {
                        return O._reject(N), Ie(N)
                    })
                })
            }).bind(null, this, d, h, l, s);
            return l ? l._promise(d, R, "lock") : ee.trans ? zt(ee.transless, function() {
                return u._whenReady(R)
            }) : this._whenReady(R)
        }, Ne.prototype.table = function(e) {
            if (!_(this._allTables, e)) throw new F.InvalidTable("Table ".concat(e, " does not exist"));
            return this._allTables[e]
        }, Ne);

        function Ne(e, n) {
            var s = this;
            this._middlewares = {}, this.verno = 0;
            var u = Ne.dependencies;
            this._options = n = a({
                addons: Ne.addons,
                autoOpen: !0,
                indexedDB: u.indexedDB,
                IDBKeyRange: u.IDBKeyRange,
                cache: "cloned"
            }, n), this._deps = {
                indexedDB: n.indexedDB,
                IDBKeyRange: n.IDBKeyRange
            }, u = n.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
            var l, d, h, y, R, w = {
                dbOpenError: null,
                isBeingOpened: !1,
                onReadyBeingFired: null,
                openComplete: !1,
                dbReadyResolve: ae,
                dbReadyPromise: null,
                cancelOpen: ae,
                openCanceller: null,
                autoSchema: !0,
                PR1398_maxLoop: 3,
                autoOpen: n.autoOpen
            };
            w.dbReadyPromise = new J(function(b) {
                w.dbReadyResolve = b
            }), w.openCanceller = new J(function(b, P) {
                w.cancelOpen = P
            }), this._state = w, this.name = e, this.on = kn(this, "populate", "blocked", "versionchange", "close", {
                ready: [Rn, ae]
            }), this.on.ready.subscribe = Q(this.on.ready.subscribe, function(b) {
                return function(P, E) {
                    Ne.vip(function() {
                        var S, x = s._state;
                        x.openComplete ? (x.dbOpenError || J.resolve().then(P), E && b(P)) : x.onReadyBeingFired ? (x.onReadyBeingFired.push(P), E && b(P)) : (b(P), S = s, E || b(function O() {
                            S.on.ready.unsubscribe(P), S.on.ready.unsubscribe(O)
                        }))
                    })
                }
            }), this.Collection = (l = this, Pn(tu.prototype, function(C, O) {
                this.db = l;
                var E = ma,
                    S = null;
                if (O) try {
                    E = O()
                } catch (I) {
                    S = I
                }
                var x = C._ctx,
                    O = x.table,
                    C = O.hook.reading.fire;
                this._ctx = {
                    table: O,
                    index: x.index,
                    isPrimKey: !x.index || O.schema.primKey.keyPath && x.index === O.schema.primKey.name,
                    range: E,
                    keysOnly: !1,
                    dir: "next",
                    unique: "",
                    algorithm: null,
                    filter: null,
                    replayFilter: null,
                    justLimit: !0,
                    isMatch: null,
                    offset: 0,
                    limit: 1 / 0,
                    error: S,
                    or: x.or,
                    valueMapper: C !== ie ? C : null
                }
            })), this.Table = (d = this, Pn(ba.prototype, function(b, P, E) {
                this.db = d, this._tx = E, this.name = b, this.schema = P, this.hook = d._allTables[b] ? d._allTables[b].hook : kn(null, {
                    creating: [Et, ae],
                    reading: [M, ie],
                    updating: [Kr, ae],
                    deleting: [Be, ae]
                })
            })), this.Transaction = (h = this, Pn(ou.prototype, function(b, P, E, S, x) {
                var O = this;
                this.db = h, this.mode = b, this.storeNames = P, this.schema = E, this.chromeTransactionDurability = S, this.idbtrans = null, this.on = kn(this, "complete", "error", "abort"), this.parent = x || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new J(function(C, I) {
                    O._resolve = C, O._reject = I
                }), this._completion.then(function() {
                    O.active = !1, O.on.complete.fire()
                }, function(C) {
                    var I = O.active;
                    return O.active = !1, O.on.error.fire(C), O.parent ? O.parent._reject(C) : I && O.idbtrans && O.idbtrans.abort(), Ie(C)
                })
            })), this.Version = (y = this, Pn(fu.prototype, function(b) {
                this.db = y, this._cfg = {
                    version: b,
                    storesSource: null,
                    dbschema: {},
                    tables: {},
                    contentUpgrade: null
                }
            })), this.WhereClause = (R = this, Pn(Oa.prototype, function(b, P, E) {
                if (this.db = R, this._ctx = {
                        table: b,
                        index: P === ":id" ? null : P,
                        or: E
                    }, this._cmp = this._ascending = we, this._descending = function(S, x) {
                        return we(x, S)
                    }, this._max = function(S, x) {
                        return 0 < we(S, x) ? S : x
                    }, this._min = function(S, x) {
                        return we(S, x) < 0 ? S : x
                    }, this._IDBKeyRange = R._deps.IDBKeyRange, !this._IDBKeyRange) throw new F.MissingAPI
            })), this.on("versionchange", function(b) {
                0 < b.newVersion ? console.warn("Another connection wants to upgrade database '".concat(s.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(s.name, "'. Closing db now to resume the delete request.")), s.close({
                    disableAutoOpen: !1
                })
            }), this.on("blocked", function(b) {
                !b.newVersion || b.newVersion < b.oldVersion ? console.warn("Dexie.delete('".concat(s.name, "') was blocked")) : console.warn("Upgrade '".concat(s.name, "' blocked by other connection holding version ").concat(b.oldVersion / 10))
            }), this._maxKey = An(n.IDBKeyRange), this._createTransaction = function(b, P, E, S) {
                return new s.Transaction(b, P, E, s._options.chromeTransactionDurability, S)
            }, this._fireOnBlocked = function(b) {
                s.on("blocked").fire(b), an.filter(function(P) {
                    return P.name === s.name && P !== s && !P._state.vcFired
                }).map(function(P) {
                    return P.on("versionchange").fire(b)
                })
            }, this.use(mu), this.use(bu), this.use(yu), this.use(hu), this.use(pu);
            var k = new Proxy(this, {
                get: function(b, P, E) {
                    if (P === "_vip") return !0;
                    if (P === "table") return function(x) {
                        return gr(s.table(x), k)
                    };
                    var S = Reflect.get(b, P, E);
                    return S instanceof ba ? gr(S, k) : P === "tables" ? S.map(function(x) {
                        return gr(x, k)
                    }) : P === "_createTransaction" ? function() {
                        return gr(S.apply(this, arguments), k)
                    } : S
                }
            });
            this.vip = k, u.forEach(function(b) {
                return b(s)
            })
        }
        var vr, ut = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable",
            _u = (bo.prototype.subscribe = function(e, n, s) {
                return this._subscribe(e && typeof e != "function" ? e : {
                    next: e,
                    error: n,
                    complete: s
                })
            }, bo.prototype[ut] = function() {
                return this
            }, bo);

        function bo(e) {
            this._subscribe = e
        }
        try {
            vr = {
                indexedDB: i.indexedDB || i.mozIndexedDB || i.webkitIndexedDB || i.msIndexedDB,
                IDBKeyRange: i.IDBKeyRange || i.webkitIDBKeyRange
            }
        } catch (e) {
            vr = {
                indexedDB: null,
                IDBKeyRange: null
            }
        }

        function ja(e) {
            var n, s = !1,
                u = new _u(function(l) {
                    var d = ze(e),
                        h, y = !1,
                        R = {},
                        w = {},
                        k = {
                            get closed() {
                                return y
                            },
                            unsubscribe: function() {
                                y || (y = !0, h && h.abort(), b && Mt.storagemutated.unsubscribe(E))
                            }
                        };
                    l.start && l.start(k);
                    var b = !1,
                        P = function() {
                            return Wr(S)
                        },
                        E = function(x) {
                            pr(R, x), lo(w, R) && P()
                        },
                        S = function() {
                            var x, O, C;
                            !y && vr.indexedDB && (R = {}, x = {}, h && h.abort(), h = new AbortController, C = function(I) {
                                var N = nn();
                                try {
                                    d && on();
                                    var D = Nt(e, I);
                                    return D = d ? D.finally(Lt) : D
                                } finally {
                                    N && rn()
                                }
                            }(O = {
                                subscr: x,
                                signal: h.signal,
                                requery: P,
                                querier: e,
                                trans: null
                            }), Promise.resolve(C).then(function(I) {
                                s = !0, n = I, y || O.signal.aborted || (R = {}, function(N) {
                                    for (var D in N)
                                        if (_(N, D)) return;
                                    return 1
                                }(w = x) || b || (Mt(Cn, E), b = !0), Wr(function() {
                                    return !y && l.next && l.next(I)
                                }))
                            }, function(I) {
                                s = !1, ["DatabaseClosedError", "AbortError"].includes(I == null ? void 0 : I.name) || y || Wr(function() {
                                    y || l.error && l.error(I)
                                })
                            }))
                        };
                    return setTimeout(P, 0), k
                });
            return u.hasValue = function() {
                return s
            }, u.getValue = function() {
                return n
            }, u
        }
        var Xt = Ct;

        function _o(e) {
            var n = jt;
            try {
                jt = !0, Mt.storagemutated.fire(e), po(e, !0)
            } finally {
                jt = n
            }
        }
        T(Xt, a(a({}, ge), {
            delete: function(e) {
                return new Xt(e, {
                    addons: []
                }).delete()
            },
            exists: function(e) {
                return new Xt(e, {
                    addons: []
                }).open().then(function(n) {
                    return n.close(), !0
                }).catch("NoSuchDatabaseError", function() {
                    return !1
                })
            },
            getDatabaseNames: function(e) {
                try {
                    return n = Xt.dependencies, s = n.indexedDB, n = n.IDBKeyRange, (so(s) ? Promise.resolve(s.databases()).then(function(u) {
                        return u.map(function(l) {
                            return l.name
                        }).filter(function(l) {
                            return l !== nr
                        })
                    }) : ao(s, n).toCollection().primaryKeys()).then(e)
                } catch (u) {
                    return Ie(new F.MissingAPI)
                }
                var n, s
            },
            defineClass: function() {
                return function(e) {
                    m(this, e)
                }
            },
            ignoreTransaction: function(e) {
                return ee.trans ? zt(ee.transless, e) : e()
            },
            vip: io,
            async: function(e) {
                return function() {
                    try {
                        var n = mo(e.apply(this, arguments));
                        return n && typeof n.then == "function" ? n : J.resolve(n)
                    } catch (s) {
                        return Ie(s)
                    }
                }
            },
            spawn: function(e, n, s) {
                try {
                    var u = mo(e.apply(s, n || []));
                    return u && typeof u.then == "function" ? u : J.resolve(u)
                } catch (l) {
                    return Ie(l)
                }
            },
            currentTransaction: {
                get: function() {
                    return ee.trans || null
                }
            },
            waitFor: function(e, n) {
                return n = J.resolve(typeof e == "function" ? Xt.ignoreTransaction(e) : e).timeout(n || 6e4), ee.trans ? ee.trans.waitFor(n) : n
            },
            Promise: J,
            debug: {
                get: function() {
                    return st
                },
                set: function(e) {
                    Gn(e)
                }
            },
            derive: q,
            extend: m,
            props: T,
            override: Q,
            Events: kn,
            on: Mt,
            liveQuery: ja,
            extendObservabilitySet: pr,
            getByKeyPath: me,
            setByKeyPath: se,
            delByKeyPath: function(e, n) {
                typeof n == "string" ? se(e, n, void 0) : "length" in n && [].map.call(n, function(s) {
                    se(e, s, void 0)
                })
            },
            shallowClone: fe,
            deepClone: Fe,
            getObjectDiff: yo,
            cmp: we,
            asap: _e,
            minKey: -1 / 0,
            addons: [],
            connections: an,
            errnames: K,
            dependencies: vr,
            cache: Jt,
            semVer: "4.0.7",
            version: "4.0.7".split(".").map(function(e) {
                return parseInt(e)
            }).reduce(function(e, n, s) {
                return e + n / Math.pow(10, 2 * s)
            })
        })), Xt.maxKey = An(Xt.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Mt(Cn, function(e) {
            jt || (e = new CustomEvent(Qr, {
                detail: e
            }), jt = !0, dispatchEvent(e), jt = !1)
        }), addEventListener(Qr, function(e) {
            e = e.detail, jt || _o(e)
        }));
        var cn, jt = !1,
            Ba = function() {};
        return typeof BroadcastChannel < "u" && ((Ba = function() {
            (cn = new BroadcastChannel(Qr)).onmessage = function(e) {
                return e.data && _o(e.data)
            }
        })(), typeof cn.unref == "function" && cn.unref(), Mt(Cn, function(e) {
            jt || cn.postMessage(e)
        })), typeof addEventListener < "u" && (addEventListener("pagehide", function(e) {
            if (!Ct.disableBfCache && e.persisted) {
                st && console.debug("Dexie: handling persisted pagehide"), cn != null && cn.close();
                for (var n = 0, s = an; n < s.length; n++) s[n].close({
                    disableAutoOpen: !1
                })
            }
        }), addEventListener("pageshow", function(e) {
            !Ct.disableBfCache && e.persisted && (st && console.debug("Dexie: handling persisted pageshow"), Ba(), _o({
                all: new Ge(-1 / 0, [
                    []
                ])
            }))
        })), J.rejectionMapper = function(e, n) {
            return !e || e instanceof Ze || e instanceof TypeError || e instanceof SyntaxError || !e.name || !Z[e.name] ? e : (n = new Z[e.name](n || e.message, e), "stack" in e && B(n, "stack", {
                get: function() {
                    return this.inner.stack
                }
            }), n)
        }, Gn(st), a(Ct, Object.freeze({
            __proto__: null,
            Dexie: Ct,
            liveQuery: ja,
            Entity: ya,
            cmp: we,
            PropModSymbol: Tt,
            PropModification: xn,
            replacePrefix: function(e, n) {
                return new xn({
                    replacePrefix: [e, n]
                })
            },
            add: function(e) {
                return new xn({
                    add: e
                })
            },
            remove: function(e) {
                return new xn({
                    remove: e
                })
            },
            default: Ct,
            RangeSet: Ge,
            mergeRanges: Ln,
            rangesOverlap: hr
        }), {
            default: Ct
        }), Ct
    })
})(ti);
var sf = ti.exports;
const To = wu(sf),
    Qa = Symbol.for("Dexie"),
    Za = globalThis[Qa] || (globalThis[Qa] = To);
if (To.semVer !== Za.semVer) throw new Error("Two different versions of Dexie loaded in the same app: ".concat(To.semVer, " and ").concat(Za.semVer));
/**
 * vue v3.4.31
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
const uf = () => {},
    vp = Object.freeze(Object.defineProperty({
        __proto__: null,
        BaseTransition: Eu,
        BaseTransitionPropsValidators: Ru,
        Comment: Ou,
        DeprecationTypes: Su,
        EffectScope: ku,
        ErrorCodes: Pu,
        ErrorTypeStrings: xu,
        Fragment: Go,
        KeepAlive: Tu,
        ReactiveEffect: Cu,
        Static: Au,
        Suspense: Iu,
        Teleport: Nu,
        Text: Us,
        TrackOpTypes: Lu,
        Transition: Fu,
        TransitionGroup: Du,
        TriggerOpTypes: Mu,
        VueElement: ju,
        assertNumber: Bu,
        callWithAsyncErrorHandling: Ku,
        callWithErrorHandling: Uu,
        camelize: qu,
        capitalize: Vu,
        cloneVNode: Hu,
        compatUtils: $u,
        compile: uf,
        computed: Ce,
        createApp: Wu,
        createBlock: zu,
        createCommentVNode: Gu,
        createElementBlock: Yu,
        createElementVNode: Ju,
        createHydrationRenderer: Xu,
        createPropsRestProxy: Qu,
        createRenderer: Zu,
        createSSRApp: ec,
        createSlots: tc,
        createStaticVNode: nc,
        createTextVNode: rc,
        createVNode: qs,
        customRef: oc,
        defineAsyncComponent: ac,
        defineComponent: _n,
        defineCustomElement: sc,
        defineEmits: ic,
        defineExpose: uc,
        defineModel: cc,
        defineOptions: lc,
        defineProps: fc,
        defineSSRCustomElement: dc,
        defineSlots: hc,
        devtools: pc,
        effect: mc,
        effectScope: xr,
        getCurrentInstance: pn,
        getCurrentScope: Vs,
        getTransitionRawChildren: yc,
        guardReactiveProps: gc,
        h: $n,
        handleError: vc,
        hasInjectionContext: Hs,
        hydrate: bc,
        initCustomFormatter: _c,
        initDirectivesForSSR: wc,
        inject: gt,
        isMemoSame: Ec,
        isProxy: Rc,
        isReactive: Tr,
        isReadonly: Oc,
        isRef: en,
        isRuntimeOnly: Sc,
        isShallow: kc,
        isVNode: Pc,
        markRaw: Yo,
        mergeDefaults: xc,
        mergeModels: Tc,
        mergeProps: Cc,
        nextTick: Jo,
        normalizeClass: Ac,
        normalizeProps: Ic,
        normalizeStyle: Nc,
        onActivated: $s,
        onBeforeMount: Ws,
        onBeforeUnmount: Lc,
        onBeforeUpdate: Fc,
        onDeactivated: zs,
        onErrorCaptured: Dc,
        onMounted: Gs,
        onRenderTracked: Mc,
        onRenderTriggered: jc,
        onScopeDispose: Ys,
        onServerPrefetch: Bc,
        onUnmounted: Xo,
        onUpdated: Kc,
        openBlock: Uc,
        popScopeId: qc,
        provide: _r,
        proxyRefs: Vc,
        pushScopeId: Hc,
        queuePostFlushCb: $c,
        reactive: Qo,
        readonly: Wc,
        ref: St,
        registerRuntimeCompiler: zc,
        render: Gc,
        renderList: Yc,
        renderSlot: Jc,
        resolveComponent: Xc,
        resolveDirective: Qc,
        resolveDynamicComponent: Zc,
        resolveFilter: el,
        resolveTransitionHooks: tl,
        setBlockTracking: nl,
        setDevtoolsHook: rl,
        setTransitionHooks: ol,
        shallowReactive: Js,
        shallowReadonly: al,
        shallowRef: Cr,
        ssrContextKey: sl,
        ssrUtils: il,
        stop: ul,
        toDisplayString: cl,
        toHandlerKey: ll,
        toHandlers: fl,
        toRaw: Zo,
        toRef: Xs,
        toRefs: Qs,
        toValue: dl,
        transformVNodeArgs: hl,
        triggerRef: pl,
        unref: hn,
        useAttrs: ml,
        useCssModule: yl,
        useCssVars: gl,
        useModel: vl,
        useSSRContext: bl,
        useSlots: _l,
        useTransitionState: wl,
        vModelCheckbox: El,
        vModelDynamic: Rl,
        vModelRadio: Ol,
        vModelSelect: Sl,
        vModelText: kl,
        vShow: Pl,
        version: xl,
        warn: Tl,
        watch: mn,
        watchEffect: Cl,
        watchPostEffect: Al,
        watchSyncEffect: Il,
        withAsyncContext: Nl,
        withCtx: Ll,
        withDefaults: Fl,
        withDirectives: Dl,
        withKeys: Ml,
        withMemo: jl,
        withModifiers: Bl,
        withScopeId: Kl
    }, Symbol.toStringTag, {
        value: "Module"
    }));
/*!
 * vue-i18n v9.13.1
 * (c) 2024 kazuya kawaguchi
 * Released under the MIT License.
 */
const cf = "9.13.1";

function lf() {
    typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (fn().__VUE_I18N_FULL_INSTALL__ = !0), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (fn().__VUE_I18N_LEGACY_API__ = !0), typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (fn().__INTLIFY_JIT_COMPILATION__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (fn().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (fn().__INTLIFY_PROD_DEVTOOLS__ = !1)
}
const ni = of .__EXTEND_POINT__,
    At = ei(ni);
At(), At(), At(), At(), At(), At(), At(), At(), At();
const ri = Xl.__EXTEND_POINT__,
    et = ei(ri),
    Me = {
        UNEXPECTED_RETURN_TYPE: ri,
        INVALID_ARGUMENT: et(),
        MUST_BE_CALL_SETUP_TOP: et(),
        NOT_INSTALLED: et(),
        NOT_AVAILABLE_IN_LEGACY_MODE: et(),
        REQUIRED_VALUE: et(),
        INVALID_VALUE: et(),
        CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: et(),
        NOT_INSTALLED_WITH_PROVIDE: et(),
        UNEXPECTED_ERROR: et(),
        NOT_COMPATIBLE_LEGACY_VUE_I18N: et(),
        BRIDGE_SUPPORT_VUE_2_ONLY: et(),
        MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: et(),
        NOT_AVAILABLE_COMPOSITION_IN_LEGACY: et(),
        __EXTEND_POINT__: et()
    };

function qe(t, ...r) {
    return $l(t, null, void 0)
}
const Co = Ht("__translateVNode"),
    Ao = Ht("__datetimeParts"),
    Io = Ht("__numberParts"),
    oi = Ht("__setPluralRules"),
    ai = Ht("__injectWithOption"),
    No = Ht("__dispose");

function Un(t) {
    if (!pt(t)) return t;
    for (const r in t)
        if (Or(t, r))
            if (!r.includes(".")) pt(t[r]) && Un(t[r]);
            else {
                const o = r.split("."),
                    a = o.length - 1;
                let c = t,
                    i = !1;
                for (let f = 0; f < a; f++) {
                    if (o[f] in c || (c[o[f]] = {}), !pt(c[o[f]])) {
                        i = !0;
                        break
                    }
                    c = c[o[f]]
                }
                i || (c[o[a]] = t[r], delete t[r]), pt(c[o[a]]) && Un(c[o[a]])
            }
    return t
}

function Ar(t, r) {
    const {
        messages: o,
        __i18n: a,
        messageResolver: c,
        flatJson: i
    } = r, f = Le(o) ? o : tt(a) ? {} : {
        [t]: {}
    };
    if (tt(a) && a.forEach(p => {
            if ("locale" in p && "resource" in p) {
                const {
                    locale: m,
                    resource: v
                } = p;
                m ? (f[m] = f[m] || {}, wr(v, f[m])) : wr(v, f)
            } else Ee(p) && wr(JSON.parse(p), f)
        }), c == null && i)
        for (const p in f) Or(f, p) && Un(f[p]);
    return f
}

function si(t) {
    return t.type
}

function ii(t, r, o) {
    let a = pt(r.messages) ? r.messages : {};
    "__i18nGlobal" in o && (a = Ar(t.locale.value, {
        messages: a,
        __i18n: o.__i18nGlobal
    }));
    const c = Object.keys(a);
    c.length && c.forEach(i => {
        t.mergeLocaleMessage(i, a[i])
    }); {
        if (pt(r.datetimeFormats)) {
            const i = Object.keys(r.datetimeFormats);
            i.length && i.forEach(f => {
                t.mergeDateTimeFormat(f, r.datetimeFormats[f])
            })
        }
        if (pt(r.numberFormats)) {
            const i = Object.keys(r.numberFormats);
            i.length && i.forEach(f => {
                t.mergeNumberFormat(f, r.numberFormats[f])
            })
        }
    }
}

function es(t) {
    return qs(Us, null, t, 0)
}
const ts = "__INTLIFY_META__",
    ns = () => [],
    ff = () => !1;
let rs = 0;

function os(t) {
    return (r, o, a, c) => t(o, a, pn() || void 0, c)
}
const df = () => {
    const t = pn();
    let r = null;
    return t && (r = si(t)[ts]) ? {
        [ts]: r
    } : null
};

function ta(t = {}, r) {
    const {
        __root: o,
        __injectWithOption: a
    } = t, c = o === void 0, i = t.flatJson, f = Sr ? St : Cr, p = !!t.translateExistCompatible;
    let m = Te(t.inheritLocale) ? t.inheritLocale : !0;
    const v = f(o && m ? o.locale.value : Ee(t.locale) ? t.locale : ea),
        g = f(o && m ? o.fallbackLocale.value : Ee(t.fallbackLocale) || tt(t.fallbackLocale) || Le(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : v.value),
        _ = f(Ar(v.value, t)),
        T = f(Le(t.datetimeFormats) ? t.datetimeFormats : {
            [v.value]: {}
        }),
        A = f(Le(t.numberFormats) ? t.numberFormats : {
            [v.value]: {}
        });
    let B = o ? o.missingWarn : Te(t.missingWarn) || gn(t.missingWarn) ? t.missingWarn : !0,
        q = o ? o.fallbackWarn : Te(t.fallbackWarn) || gn(t.fallbackWarn) ? t.fallbackWarn : !0,
        re = o ? o.fallbackRoot : Te(t.fallbackRoot) ? t.fallbackRoot : !0,
        oe = !!t.fallbackFormat,
        te = Vt(t.missing) ? t.missing : null,
        Q = Vt(t.missing) ? os(t.missing) : null,
        ye = Vt(t.postTranslation) ? t.postTranslation : null,
        _e = o ? o.warnHtmlMessage : Te(t.warnHtmlMessage) ? t.warnHtmlMessage : !0,
        me = !!t.escapeParameter;
    const se = o ? o.modifiers : Le(t.modifiers) ? t.modifiers : {};
    let fe = t.pluralRules || o && o.pluralRules,
        z;
    z = (() => {
        c && Xa(null);
        const j = {
            version: cf,
            locale: v.value,
            fallbackLocale: g.value,
            messages: _.value,
            modifiers: se,
            pluralRules: fe,
            missing: Q === null ? void 0 : Q,
            missingWarn: B,
            fallbackWarn: q,
            fallbackFormat: oe,
            unresolving: !0,
            postTranslation: ye === null ? void 0 : ye,
            warnHtmlMessage: _e,
            escapeParameter: me,
            messageResolver: t.messageResolver,
            messageCompiler: t.messageCompiler,
            __meta: {
                framework: "vue"
            }
        };
        j.datetimeFormats = T.value, j.numberFormats = A.value, j.__datetimeFormatters = Le(z) ? z.__datetimeFormatters : void 0, j.__numberFormatters = Le(z) ? z.__numberFormatters : void 0;
        const V = Ql(j);
        return c && Xa(V), V
    })(), Fn(z, v.value, g.value);

    function Ve() {
        return [v.value, g.value, _.value, T.value, A.value]
    }
    const je = Ce({
            get: () => v.value,
            set: j => {
                v.value = j, z.locale = v.value
            }
        }),
        Fe = Ce({
            get: () => g.value,
            set: j => {
                g.value = j, z.fallbackLocale = g.value, Fn(z, v.value, j)
            }
        }),
        kt = Ce(() => _.value),
        He = Ce(() => T.value),
        Oe = Ce(() => A.value);

    function _t() {
        return Vt(ye) ? ye : null
    }

    function Xe(j) {
        ye = j, z.postTranslation = j
    }

    function at() {
        return te
    }

    function $e(j) {
        j !== null && (Q = os(j)), te = j, z.missing = Q
    }
    const ze = (j, V, ve, Se, rt, it) => {
        Ve();
        let dt;
        try {
            __INTLIFY_PROD_DEVTOOLS__ && Zl(df()), c || (z.fallbackContext = o ? ef() : void 0), dt = j(z)
        } finally {
            __INTLIFY_PROD_DEVTOOLS__,
            c || (z.fallbackContext = void 0)
        }
        if (ve !== "translate exists" && yn(dt) && dt === tf || ve === "translate exists" && !dt) {
            const [On, Pt] = V();
            return o && re ? Se(o) : rt(On)
        } else {
            if (it(dt)) return dt;
            throw qe(Me.UNEXPECTED_RETURN_TYPE)
        }
    };

    function wt(...j) {
        return ze(V => Reflect.apply($a, null, [V, ...j]), () => Ha(...j), "translate", V => Reflect.apply(V.t, V, [...j]), V => V, V => Ee(V))
    }

    function Ze(...j) {
        const [V, ve, Se] = j;
        if (Se && !pt(Se)) throw qe(Me.INVALID_ARGUMENT);
        return wt(V, ve, mt({
            resolvedMessage: !0
        }, Se || {}))
    }

    function lt(...j) {
        return ze(V => Reflect.apply(Ga, null, [V, ...j]), () => za(...j), "datetime format", V => Reflect.apply(V.d, V, [...j]), () => Wa, V => Ee(V))
    }

    function ft(...j) {
        return ze(V => Reflect.apply(Ja, null, [V, ...j]), () => Ya(...j), "number format", V => Reflect.apply(V.n, V, [...j]), () => Wa, V => Ee(V))
    }

    function We(j) {
        return j.map(V => Ee(V) || yn(V) || Te(V) ? es(String(V)) : V)
    }
    const X = {
        normalize: We,
        interpolate: j => j,
        type: "vnode"
    };

    function F(...j) {
        return ze(V => {
            let ve;
            const Se = V;
            try {
                Se.processor = X, ve = Reflect.apply($a, null, [Se, ...j])
            } finally {
                Se.processor = null
            }
            return ve
        }, () => Ha(...j), "translate", V => V[Co](...j), V => [es(V)], V => tt(V))
    }

    function Z(...j) {
        return ze(V => Reflect.apply(Ja, null, [V, ...j]), () => Ya(...j), "number format", V => V[Io](...j), ns, V => Ee(V) || tt(V))
    }

    function ge(...j) {
        return ze(V => Reflect.apply(Ga, null, [V, ...j]), () => za(...j), "datetime format", V => V[Ao](...j), ns, V => Ee(V) || tt(V))
    }

    function ae(j) {
        fe = j, z.pluralRules = fe
    }

    function ie(j, V) {
        return ze(() => {
            if (!j) return !1;
            const ve = Ee(V) ? V : v.value,
                Se = Et(ve),
                rt = z.messageResolver(Se, j);
            return p ? rt != null : nf(rt) || rf(rt) || Ee(rt)
        }, () => [j], "translate exists", ve => Reflect.apply(ve.te, ve, [j, V]), ff, ve => Te(ve))
    }

    function M(j) {
        let V = null;
        const ve = Zs(z, g.value, v.value);
        for (let Se = 0; Se < ve.length; Se++) {
            const rt = _.value[ve[Se]] || {},
                it = z.messageResolver(rt, j);
            if (it != null) {
                V = it;
                break
            }
        }
        return V
    }

    function ne(j) {
        const V = M(j);
        return V != null ? V : o ? o.tm(j) || {} : {}
    }

    function Et(j) {
        return _.value[j] || {}
    }

    function Be(j, V) {
        if (i) {
            const ve = {
                [j]: V
            };
            for (const Se in ve) Or(ve, Se) && Un(ve[Se]);
            V = ve[j]
        }
        _.value[j] = V, z.messages = _.value
    }

    function Kr(j, V) {
        _.value[j] = _.value[j] || {};
        const ve = {
            [j]: V
        };
        if (i)
            for (const Se in ve) Or(ve, Se) && Un(ve[Se]);
        V = ve[j], wr(V, _.value[j]), z.messages = _.value
    }

    function Ur(j) {
        return T.value[j] || {}
    }

    function Rn(j, V) {
        T.value[j] = V, z.datetimeFormats = T.value, qa(z, j, V)
    }

    function st(j, V) {
        T.value[j] = mt(T.value[j] || {}, V), z.datetimeFormats = T.value, qa(z, j, V)
    }

    function Gn(j) {
        return A.value[j] || {}
    }

    function $t(j, V) {
        A.value[j] = V, z.numberFormats = A.value, Va(z, j, V)
    }

    function Yn(j, V) {
        A.value[j] = mt(A.value[j] || {}, V), z.numberFormats = A.value, Va(z, j, V)
    }
    rs++, o && Sr && (mn(o.locale, j => {
        m && (v.value = j, z.locale = j, Fn(z, v.value, g.value))
    }), mn(o.fallbackLocale, j => {
        m && (g.value = j, z.fallbackLocale = j, Fn(z, v.value, g.value))
    }));
    const Pe = {
        id: rs,
        locale: je,
        fallbackLocale: Fe,
        get inheritLocale() {
            return m
        },
        set inheritLocale(j) {
            m = j, j && o && (v.value = o.locale.value, g.value = o.fallbackLocale.value, Fn(z, v.value, g.value))
        },
        get availableLocales() {
            return Object.keys(_.value).sort()
        },
        messages: kt,
        get modifiers() {
            return se
        },
        get pluralRules() {
            return fe || {}
        },
        get isGlobal() {
            return c
        },
        get missingWarn() {
            return B
        },
        set missingWarn(j) {
            B = j, z.missingWarn = B
        },
        get fallbackWarn() {
            return q
        },
        set fallbackWarn(j) {
            q = j, z.fallbackWarn = q
        },
        get fallbackRoot() {
            return re
        },
        set fallbackRoot(j) {
            re = j
        },
        get fallbackFormat() {
            return oe
        },
        set fallbackFormat(j) {
            oe = j, z.fallbackFormat = oe
        },
        get warnHtmlMessage() {
            return _e
        },
        set warnHtmlMessage(j) {
            _e = j, z.warnHtmlMessage = j
        },
        get escapeParameter() {
            return me
        },
        set escapeParameter(j) {
            me = j, z.escapeParameter = j
        },
        t: wt,
        getLocaleMessage: Et,
        setLocaleMessage: Be,
        mergeLocaleMessage: Kr,
        getPostTranslationHandler: _t,
        setPostTranslationHandler: Xe,
        getMissingHandler: at,
        setMissingHandler: $e,
        [oi]: ae
    };
    return Pe.datetimeFormats = He, Pe.numberFormats = Oe, Pe.rt = Ze, Pe.te = ie, Pe.tm = ne, Pe.d = lt, Pe.n = ft, Pe.getDateTimeFormat = Ur, Pe.setDateTimeFormat = Rn, Pe.mergeDateTimeFormat = st, Pe.getNumberFormat = Gn, Pe.setNumberFormat = $t, Pe.mergeNumberFormat = Yn, Pe[ai] = a, Pe[Co] = F, Pe[Ao] = ge, Pe[Io] = Z, Pe
}

function hf(t) {
    const r = Ee(t.locale) ? t.locale : ea,
        o = Ee(t.fallbackLocale) || tt(t.fallbackLocale) || Le(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : r,
        a = Vt(t.missing) ? t.missing : void 0,
        c = Te(t.silentTranslationWarn) || gn(t.silentTranslationWarn) ? !t.silentTranslationWarn : !0,
        i = Te(t.silentFallbackWarn) || gn(t.silentFallbackWarn) ? !t.silentFallbackWarn : !0,
        f = Te(t.fallbackRoot) ? t.fallbackRoot : !0,
        p = !!t.formatFallbackMessages,
        m = Le(t.modifiers) ? t.modifiers : {},
        v = t.pluralizationRules,
        g = Vt(t.postTranslation) ? t.postTranslation : void 0,
        _ = Ee(t.warnHtmlInMessage) ? t.warnHtmlInMessage !== "off" : !0,
        T = !!t.escapeParameterHtml,
        A = Te(t.sync) ? t.sync : !0;
    let B = t.messages;
    if (Le(t.sharedMessages)) {
        const me = t.sharedMessages;
        B = Object.keys(me).reduce((fe, z) => {
            const Ae = fe[z] || (fe[z] = {});
            return mt(Ae, me[z]), fe
        }, B || {})
    }
    const {
        __i18n: q,
        __root: re,
        __injectWithOption: oe
    } = t, te = t.datetimeFormats, Q = t.numberFormats, ye = t.flatJson, _e = t.translateExistCompatible;
    return {
        locale: r,
        fallbackLocale: o,
        messages: B,
        flatJson: ye,
        datetimeFormats: te,
        numberFormats: Q,
        missing: a,
        missingWarn: c,
        fallbackWarn: i,
        fallbackRoot: f,
        fallbackFormat: p,
        modifiers: m,
        pluralRules: v,
        postTranslation: g,
        warnHtmlMessage: _,
        escapeParameter: T,
        messageResolver: t.messageResolver,
        inheritLocale: A,
        translateExistCompatible: _e,
        __i18n: q,
        __root: re,
        __injectWithOption: oe
    }
}

function Lo(t = {}, r) {
    {
        const o = ta(hf(t)),
            {
                __extender: a
            } = t,
            c = {
                id: o.id,
                get locale() {
                    return o.locale.value
                },
                set locale(i) {
                    o.locale.value = i
                },
                get fallbackLocale() {
                    return o.fallbackLocale.value
                },
                set fallbackLocale(i) {
                    o.fallbackLocale.value = i
                },
                get messages() {
                    return o.messages.value
                },
                get datetimeFormats() {
                    return o.datetimeFormats.value
                },
                get numberFormats() {
                    return o.numberFormats.value
                },
                get availableLocales() {
                    return o.availableLocales
                },
                get formatter() {
                    return {
                        interpolate() {
                            return []
                        }
                    }
                },
                set formatter(i) {},
                get missing() {
                    return o.getMissingHandler()
                },
                set missing(i) {
                    o.setMissingHandler(i)
                },
                get silentTranslationWarn() {
                    return Te(o.missingWarn) ? !o.missingWarn : o.missingWarn
                },
                set silentTranslationWarn(i) {
                    o.missingWarn = Te(i) ? !i : i
                },
                get silentFallbackWarn() {
                    return Te(o.fallbackWarn) ? !o.fallbackWarn : o.fallbackWarn
                },
                set silentFallbackWarn(i) {
                    o.fallbackWarn = Te(i) ? !i : i
                },
                get modifiers() {
                    return o.modifiers
                },
                get formatFallbackMessages() {
                    return o.fallbackFormat
                },
                set formatFallbackMessages(i) {
                    o.fallbackFormat = i
                },
                get postTranslation() {
                    return o.getPostTranslationHandler()
                },
                set postTranslation(i) {
                    o.setPostTranslationHandler(i)
                },
                get sync() {
                    return o.inheritLocale
                },
                set sync(i) {
                    o.inheritLocale = i
                },
                get warnHtmlInMessage() {
                    return o.warnHtmlMessage ? "warn" : "off"
                },
                set warnHtmlInMessage(i) {
                    o.warnHtmlMessage = i !== "off"
                },
                get escapeParameterHtml() {
                    return o.escapeParameter
                },
                set escapeParameterHtml(i) {
                    o.escapeParameter = i
                },
                get preserveDirectiveContent() {
                    return !0
                },
                set preserveDirectiveContent(i) {},
                get pluralizationRules() {
                    return o.pluralRules || {}
                },
                __composer: o,
                t(...i) {
                    const [f, p, m] = i, v = {};
                    let g = null,
                        _ = null;
                    if (!Ee(f)) throw qe(Me.INVALID_ARGUMENT);
                    const T = f;
                    return Ee(p) ? v.locale = p : tt(p) ? g = p : Le(p) && (_ = p), tt(m) ? g = m : Le(m) && (_ = m), Reflect.apply(o.t, o, [T, g || _ || {}, v])
                },
                rt(...i) {
                    return Reflect.apply(o.rt, o, [...i])
                },
                tc(...i) {
                    const [f, p, m] = i, v = {
                        plural: 1
                    };
                    let g = null,
                        _ = null;
                    if (!Ee(f)) throw qe(Me.INVALID_ARGUMENT);
                    const T = f;
                    return Ee(p) ? v.locale = p : yn(p) ? v.plural = p : tt(p) ? g = p : Le(p) && (_ = p), Ee(m) ? v.locale = m : tt(m) ? g = m : Le(m) && (_ = m), Reflect.apply(o.t, o, [T, g || _ || {}, v])
                },
                te(i, f) {
                    return o.te(i, f)
                },
                tm(i) {
                    return o.tm(i)
                },
                getLocaleMessage(i) {
                    return o.getLocaleMessage(i)
                },
                setLocaleMessage(i, f) {
                    o.setLocaleMessage(i, f)
                },
                mergeLocaleMessage(i, f) {
                    o.mergeLocaleMessage(i, f)
                },
                d(...i) {
                    return Reflect.apply(o.d, o, [...i])
                },
                getDateTimeFormat(i) {
                    return o.getDateTimeFormat(i)
                },
                setDateTimeFormat(i, f) {
                    o.setDateTimeFormat(i, f)
                },
                mergeDateTimeFormat(i, f) {
                    o.mergeDateTimeFormat(i, f)
                },
                n(...i) {
                    return Reflect.apply(o.n, o, [...i])
                },
                getNumberFormat(i) {
                    return o.getNumberFormat(i)
                },
                setNumberFormat(i, f) {
                    o.setNumberFormat(i, f)
                },
                mergeNumberFormat(i, f) {
                    o.mergeNumberFormat(i, f)
                },
                getChoiceIndex(i, f) {
                    return -1
                }
            };
        return c.__extender = a, c
    }
}
const na = {
    tag: {
        type: [String, Object]
    },
    locale: {
        type: String
    },
    scope: {
        type: String,
        validator: t => t === "parent" || t === "global",
        default: "parent"
    },
    i18n: {
        type: Object
    }
};

function pf({
    slots: t
}, r) {
    return r.length === 1 && r[0] === "default" ? (t.default ? t.default() : []).reduce((a, c) => [...a, ...c.type === Go ? c.children : [c]], []) : r.reduce((o, a) => {
        const c = t[a];
        return c && (o[a] = c()), o
    }, {})
}

function ui(t) {
    return Go
}
const mf = _n({
        name: "i18n-t",
        props: mt({
            keypath: {
                type: String,
                required: !0
            },
            plural: {
                type: [Number, String],
                validator: t => yn(t) || !isNaN(t)
            }
        }, na),
        setup(t, r) {
            const {
                slots: o,
                attrs: a
            } = r, c = t.i18n || ra({
                useScope: t.scope,
                __useComponent: !0
            });
            return () => {
                const i = Object.keys(o).filter(_ => _ !== "_"),
                    f = {};
                t.locale && (f.locale = t.locale), t.plural !== void 0 && (f.plural = Ee(t.plural) ? +t.plural : t.plural);
                const p = pf(r, i),
                    m = c[Co](t.keypath, p, f),
                    v = mt({}, a),
                    g = Ee(t.tag) || pt(t.tag) ? t.tag : ui();
                return $n(g, v, m)
            }
        }
    }),
    Fo = mf,
    bp = Fo;

function yf(t) {
    return tt(t) && !Ee(t[0])
}

function ci(t, r, o, a) {
    const {
        slots: c,
        attrs: i
    } = r;
    return () => {
        const f = {
            part: !0
        };
        let p = {};
        t.locale && (f.locale = t.locale), Ee(t.format) ? f.key = t.format : pt(t.format) && (Ee(t.format.key) && (f.key = t.format.key), p = Object.keys(t.format).reduce((T, A) => o.includes(A) ? mt({}, T, {
            [A]: t.format[A]
        }) : T, {}));
        const m = a(t.value, f, p);
        let v = [f.key];
        tt(m) ? v = m.map((T, A) => {
            const B = c[T.type],
                q = B ? B({
                    [T.type]: T.value,
                    index: A,
                    parts: m
                }) : [T.value];
            return yf(q) && (q[0].key = "".concat(T.type, "-").concat(A)), q
        }) : Ee(m) && (v = [m]);
        const g = mt({}, i),
            _ = Ee(t.tag) || pt(t.tag) ? t.tag : ui();
        return $n(_, g, v)
    }
}
const gf = _n({
        name: "i18n-n",
        props: mt({
            value: {
                type: Number,
                required: !0
            },
            format: {
                type: [String, Object]
            }
        }, na),
        setup(t, r) {
            const o = t.i18n || ra({
                useScope: t.scope,
                __useComponent: !0
            });
            return ci(t, r, Wl, (...a) => o[Io](...a))
        }
    }),
    as = gf,
    vf = _n({
        name: "i18n-d",
        props: mt({
            value: {
                type: [Number, Date],
                required: !0
            },
            format: {
                type: [String, Object]
            }
        }, na),
        setup(t, r) {
            const o = t.i18n || ra({
                useScope: t.scope,
                __useComponent: !0
            });
            return ci(t, r, zl, (...a) => o[Ao](...a))
        }
    }),
    ss = vf;

function bf(t, r) {
    const o = t;
    if (t.mode === "composition") return o.__getInstance(r) || t.global; {
        const a = o.__getInstance(r);
        return a != null ? a.__composer : t.global.__composer
    }
}

function _f(t) {
    const r = f => {
        const {
            instance: p,
            modifiers: m,
            value: v
        } = f;
        if (!p || !p.$) throw qe(Me.UNEXPECTED_ERROR);
        const g = bf(t, p.$),
            _ = is(v);
        return [Reflect.apply(g.t, g, [...us(_)]), g]
    };
    return {
        created: (f, p) => {
            const [m, v] = r(p);
            Sr && t.global === v && (f.__i18nWatcher = mn(v.locale, () => {
                p.instance && p.instance.$forceUpdate()
            })), f.__composer = v, f.textContent = m
        },
        unmounted: f => {
            Sr && f.__i18nWatcher && (f.__i18nWatcher(), f.__i18nWatcher = void 0, delete f.__i18nWatcher), f.__composer && (f.__composer = void 0, delete f.__composer)
        },
        beforeUpdate: (f, {
            value: p
        }) => {
            if (f.__composer) {
                const m = f.__composer,
                    v = is(p);
                f.textContent = Reflect.apply(m.t, m, [...us(v)])
            }
        },
        getSSRProps: f => {
            const [p] = r(f);
            return {
                textContent: p
            }
        }
    }
}

function is(t) {
    if (Ee(t)) return {
        path: t
    };
    if (Le(t)) {
        if (!("path" in t)) throw qe(Me.REQUIRED_VALUE, "path");
        return t
    } else throw qe(Me.INVALID_VALUE)
}

function us(t) {
    const {
        path: r,
        locale: o,
        args: a,
        choice: c,
        plural: i
    } = t, f = {}, p = a || {};
    return Ee(o) && (f.locale = o), yn(c) && (f.plural = c), yn(i) && (f.plural = i), [r, p, f]
}

function wf(t, r, ...o) {
    const a = Le(o[0]) ? o[0] : {},
        c = !!a.useI18nComponentName;
    (Te(a.globalInstall) ? a.globalInstall : !0) && ([c ? "i18n" : Fo.name, "I18nT"].forEach(f => t.component(f, Fo)), [as.name, "I18nN"].forEach(f => t.component(f, as)), [ss.name, "I18nD"].forEach(f => t.component(f, ss))), t.directive("t", _f(r))
}

function Ef(t, r, o) {
    return {
        beforeCreate() {
            const a = pn();
            if (!a) throw qe(Me.UNEXPECTED_ERROR);
            const c = this.$options;
            if (c.i18n) {
                const i = c.i18n;
                if (c.__i18n && (i.__i18n = c.__i18n), i.__root = r, this === this.$root) this.$i18n = cs(t, i);
                else {
                    i.__injectWithOption = !0, i.__extender = o.__vueI18nExtend, this.$i18n = Lo(i);
                    const f = this.$i18n;
                    f.__extender && (f.__disposer = f.__extender(this.$i18n))
                }
            } else if (c.__i18n)
                if (this === this.$root) this.$i18n = cs(t, c);
                else {
                    this.$i18n = Lo({
                        __i18n: c.__i18n,
                        __injectWithOption: !0,
                        __extender: o.__vueI18nExtend,
                        __root: r
                    });
                    const i = this.$i18n;
                    i.__extender && (i.__disposer = i.__extender(this.$i18n))
                }
            else this.$i18n = t;
            c.__i18nGlobal && ii(r, c, c), this.$t = (...i) => this.$i18n.t(...i), this.$rt = (...i) => this.$i18n.rt(...i), this.$tc = (...i) => this.$i18n.tc(...i), this.$te = (i, f) => this.$i18n.te(i, f), this.$d = (...i) => this.$i18n.d(...i), this.$n = (...i) => this.$i18n.n(...i), this.$tm = i => this.$i18n.tm(i), o.__setInstance(a, this.$i18n)
        },
        mounted() {},
        unmounted() {
            const a = pn();
            if (!a) throw qe(Me.UNEXPECTED_ERROR);
            const c = this.$i18n;
            delete this.$t, delete this.$rt, delete this.$tc, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, c.__disposer && (c.__disposer(), delete c.__disposer, delete c.__extender), o.__deleteInstance(a), delete this.$i18n
        }
    }
}

function cs(t, r) {
    t.locale = r.locale || t.locale, t.fallbackLocale = r.fallbackLocale || t.fallbackLocale, t.missing = r.missing || t.missing, t.silentTranslationWarn = r.silentTranslationWarn || t.silentFallbackWarn, t.silentFallbackWarn = r.silentFallbackWarn || t.silentFallbackWarn, t.formatFallbackMessages = r.formatFallbackMessages || t.formatFallbackMessages, t.postTranslation = r.postTranslation || t.postTranslation, t.warnHtmlInMessage = r.warnHtmlInMessage || t.warnHtmlInMessage, t.escapeParameterHtml = r.escapeParameterHtml || t.escapeParameterHtml, t.sync = r.sync || t.sync, t.__composer[oi](r.pluralizationRules || t.pluralizationRules);
    const o = Ar(t.locale, {
        messages: r.messages,
        __i18n: r.__i18n
    });
    return Object.keys(o).forEach(a => t.mergeLocaleMessage(a, o[a])), r.datetimeFormats && Object.keys(r.datetimeFormats).forEach(a => t.mergeDateTimeFormat(a, r.datetimeFormats[a])), r.numberFormats && Object.keys(r.numberFormats).forEach(a => t.mergeNumberFormat(a, r.numberFormats[a])), t
}
const Rf = Ht("global-vue-i18n");

function _p(t = {}, r) {
    const o = __VUE_I18N_LEGACY_API__ && Te(t.legacy) ? t.legacy : __VUE_I18N_LEGACY_API__,
        a = Te(t.globalInjection) ? t.globalInjection : !0,
        c = __VUE_I18N_LEGACY_API__ && o ? !!t.allowComposition : !0,
        i = new Map,
        [f, p] = Of(t, o),
        m = Ht("");

    function v(T) {
        return i.get(T) || null
    }

    function g(T, A) {
        i.set(T, A)
    }

    function _(T) {
        i.delete(T)
    } {
        const T = {
            get mode() {
                return __VUE_I18N_LEGACY_API__ && o ? "legacy" : "composition"
            },
            get allowComposition() {
                return c
            },
            async install(A, ...B) {
                if (A.__VUE_I18N_SYMBOL__ = m, A.provide(A.__VUE_I18N_SYMBOL__, T), Le(B[0])) {
                    const oe = B[0];
                    T.__composerExtend = oe.__composerExtend, T.__vueI18nExtend = oe.__vueI18nExtend
                }
                let q = null;
                !o && a && (q = Nf(A, T.global)), __VUE_I18N_FULL_INSTALL__ && wf(A, T, ...B), __VUE_I18N_LEGACY_API__ && o && A.mixin(Ef(p, p.__composer, T));
                const re = A.unmount;
                A.unmount = () => {
                    q && q(), T.dispose(), re()
                }
            },
            get global() {
                return p
            },
            dispose() {
                f.stop()
            },
            __instances: i,
            __getInstance: v,
            __setInstance: g,
            __deleteInstance: _
        };
        return T
    }
}

function ra(t = {}) {
    const r = pn();
    if (r == null) throw qe(Me.MUST_BE_CALL_SETUP_TOP);
    if (!r.isCE && r.appContext.app != null && !r.appContext.app.__VUE_I18N_SYMBOL__) throw qe(Me.NOT_INSTALLED);
    const o = Sf(r),
        a = Pf(o),
        c = si(r),
        i = kf(t, c);
    if (__VUE_I18N_LEGACY_API__ && o.mode === "legacy" && !t.__useComponent) {
        if (!o.allowComposition) throw qe(Me.NOT_AVAILABLE_IN_LEGACY_MODE);
        return Af(r, i, a, t)
    }
    if (i === "global") return ii(a, t, c), a;
    if (i === "parent") {
        let m = xf(o, r, t.__useComponent);
        return m == null && (m = a), m
    }
    const f = o;
    let p = f.__getInstance(r);
    if (p == null) {
        const m = mt({}, t);
        "__i18n" in c && (m.__i18n = c.__i18n), a && (m.__root = a), p = ta(m), f.__composerExtend && (p[No] = f.__composerExtend(p)), Cf(f, r, p), f.__setInstance(r, p)
    }
    return p
}

function Of(t, r, o) {
    const a = xr(); {
        const c = __VUE_I18N_LEGACY_API__ && r ? a.run(() => Lo(t)) : a.run(() => ta(t));
        if (c == null) throw qe(Me.UNEXPECTED_ERROR);
        return [a, c]
    }
}

function Sf(t) {
    {
        const r = gt(t.isCE ? Rf : t.appContext.app.__VUE_I18N_SYMBOL__);
        if (!r) throw qe(t.isCE ? Me.NOT_INSTALLED_WITH_PROVIDE : Me.UNEXPECTED_ERROR);
        return r
    }
}

function kf(t, r) {
    return Ul(t) ? "__i18n" in r ? "local" : "global" : t.useScope ? t.useScope : "local"
}

function Pf(t) {
    return t.mode === "composition" ? t.global : t.global.__composer
}

function xf(t, r, o = !1) {
    let a = null;
    const c = r.root;
    let i = Tf(r, o);
    for (; i != null;) {
        const f = t;
        if (t.mode === "composition") a = f.__getInstance(i);
        else if (__VUE_I18N_LEGACY_API__) {
            const p = f.__getInstance(i);
            p != null && (a = p.__composer, o && a && !a[ai] && (a = null))
        }
        if (a != null || c === i) break;
        i = i.parent
    }
    return a
}

function Tf(t, r = !1) {
    return t == null ? null : r && t.vnode.ctx || t.parent
}

function Cf(t, r, o) {
    Gs(() => {}, r), Xo(() => {
        const a = o;
        t.__deleteInstance(r);
        const c = a[No];
        c && (c(), delete a[No])
    }, r)
}

function Af(t, r, o, a = {}) {
    const c = r === "local",
        i = Cr(null);
    if (c && t.proxy && !(t.proxy.$options.i18n || t.proxy.$options.__i18n)) throw qe(Me.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
    const f = Te(a.inheritLocale) ? a.inheritLocale : !Ee(a.locale),
        p = St(!c || f ? o.locale.value : Ee(a.locale) ? a.locale : ea),
        m = St(!c || f ? o.fallbackLocale.value : Ee(a.fallbackLocale) || tt(a.fallbackLocale) || Le(a.fallbackLocale) || a.fallbackLocale === !1 ? a.fallbackLocale : p.value),
        v = St(Ar(p.value, a)),
        g = St(Le(a.datetimeFormats) ? a.datetimeFormats : {
            [p.value]: {}
        }),
        _ = St(Le(a.numberFormats) ? a.numberFormats : {
            [p.value]: {}
        }),
        T = c ? o.missingWarn : Te(a.missingWarn) || gn(a.missingWarn) ? a.missingWarn : !0,
        A = c ? o.fallbackWarn : Te(a.fallbackWarn) || gn(a.fallbackWarn) ? a.fallbackWarn : !0,
        B = c ? o.fallbackRoot : Te(a.fallbackRoot) ? a.fallbackRoot : !0,
        q = !!a.fallbackFormat,
        re = Vt(a.missing) ? a.missing : null,
        oe = Vt(a.postTranslation) ? a.postTranslation : null,
        te = c ? o.warnHtmlMessage : Te(a.warnHtmlMessage) ? a.warnHtmlMessage : !0,
        Q = !!a.escapeParameter,
        ye = c ? o.modifiers : Le(a.modifiers) ? a.modifiers : {},
        _e = a.pluralRules || c && o.pluralRules;

    function me() {
        return [p.value, m.value, v.value, g.value, _.value]
    }
    const se = Ce({
            get: () => i.value ? i.value.locale.value : p.value,
            set: M => {
                i.value && (i.value.locale.value = M), p.value = M
            }
        }),
        fe = Ce({
            get: () => i.value ? i.value.fallbackLocale.value : m.value,
            set: M => {
                i.value && (i.value.fallbackLocale.value = M), m.value = M
            }
        }),
        z = Ce(() => i.value ? i.value.messages.value : v.value),
        Ae = Ce(() => g.value),
        Ve = Ce(() => _.value);

    function je() {
        return i.value ? i.value.getPostTranslationHandler() : oe
    }

    function Fe(M) {
        i.value && i.value.setPostTranslationHandler(M)
    }

    function kt() {
        return i.value ? i.value.getMissingHandler() : re
    }

    function He(M) {
        i.value && i.value.setMissingHandler(M)
    }

    function Oe(M) {
        return me(), M()
    }

    function _t(...M) {
        return i.value ? Oe(() => Reflect.apply(i.value.t, null, [...M])) : Oe(() => "")
    }

    function Xe(...M) {
        return i.value ? Reflect.apply(i.value.rt, null, [...M]) : ""
    }

    function at(...M) {
        return i.value ? Oe(() => Reflect.apply(i.value.d, null, [...M])) : Oe(() => "")
    }

    function $e(...M) {
        return i.value ? Oe(() => Reflect.apply(i.value.n, null, [...M])) : Oe(() => "")
    }

    function ze(M) {
        return i.value ? i.value.tm(M) : {}
    }

    function wt(M, ne) {
        return i.value ? i.value.te(M, ne) : !1
    }

    function Ze(M) {
        return i.value ? i.value.getLocaleMessage(M) : {}
    }

    function lt(M, ne) {
        i.value && (i.value.setLocaleMessage(M, ne), v.value[M] = ne)
    }

    function ft(M, ne) {
        i.value && i.value.mergeLocaleMessage(M, ne)
    }

    function We(M) {
        return i.value ? i.value.getDateTimeFormat(M) : {}
    }

    function K(M, ne) {
        i.value && (i.value.setDateTimeFormat(M, ne), g.value[M] = ne)
    }

    function X(M, ne) {
        i.value && i.value.mergeDateTimeFormat(M, ne)
    }

    function F(M) {
        return i.value ? i.value.getNumberFormat(M) : {}
    }

    function Z(M, ne) {
        i.value && (i.value.setNumberFormat(M, ne), _.value[M] = ne)
    }

    function ge(M, ne) {
        i.value && i.value.mergeNumberFormat(M, ne)
    }
    const ae = {
        get id() {
            return i.value ? i.value.id : -1
        },
        locale: se,
        fallbackLocale: fe,
        messages: z,
        datetimeFormats: Ae,
        numberFormats: Ve,
        get inheritLocale() {
            return i.value ? i.value.inheritLocale : f
        },
        set inheritLocale(M) {
            i.value && (i.value.inheritLocale = M)
        },
        get availableLocales() {
            return i.value ? i.value.availableLocales : Object.keys(v.value)
        },
        get modifiers() {
            return i.value ? i.value.modifiers : ye
        },
        get pluralRules() {
            return i.value ? i.value.pluralRules : _e
        },
        get isGlobal() {
            return i.value ? i.value.isGlobal : !1
        },
        get missingWarn() {
            return i.value ? i.value.missingWarn : T
        },
        set missingWarn(M) {
            i.value && (i.value.missingWarn = M)
        },
        get fallbackWarn() {
            return i.value ? i.value.fallbackWarn : A
        },
        set fallbackWarn(M) {
            i.value && (i.value.missingWarn = M)
        },
        get fallbackRoot() {
            return i.value ? i.value.fallbackRoot : B
        },
        set fallbackRoot(M) {
            i.value && (i.value.fallbackRoot = M)
        },
        get fallbackFormat() {
            return i.value ? i.value.fallbackFormat : q
        },
        set fallbackFormat(M) {
            i.value && (i.value.fallbackFormat = M)
        },
        get warnHtmlMessage() {
            return i.value ? i.value.warnHtmlMessage : te
        },
        set warnHtmlMessage(M) {
            i.value && (i.value.warnHtmlMessage = M)
        },
        get escapeParameter() {
            return i.value ? i.value.escapeParameter : Q
        },
        set escapeParameter(M) {
            i.value && (i.value.escapeParameter = M)
        },
        t: _t,
        getPostTranslationHandler: je,
        setPostTranslationHandler: Fe,
        getMissingHandler: kt,
        setMissingHandler: He,
        rt: Xe,
        d: at,
        n: $e,
        tm: ze,
        te: wt,
        getLocaleMessage: Ze,
        setLocaleMessage: lt,
        mergeLocaleMessage: ft,
        getDateTimeFormat: We,
        setDateTimeFormat: K,
        mergeDateTimeFormat: X,
        getNumberFormat: F,
        setNumberFormat: Z,
        mergeNumberFormat: ge
    };

    function ie(M) {
        M.locale.value = p.value, M.fallbackLocale.value = m.value, Object.keys(v.value).forEach(ne => {
            M.mergeLocaleMessage(ne, v.value[ne])
        }), Object.keys(g.value).forEach(ne => {
            M.mergeDateTimeFormat(ne, g.value[ne])
        }), Object.keys(_.value).forEach(ne => {
            M.mergeNumberFormat(ne, _.value[ne])
        }), M.escapeParameter = Q, M.fallbackFormat = q, M.fallbackRoot = B, M.fallbackWarn = A, M.missingWarn = T, M.warnHtmlMessage = te
    }
    return Ws(() => {
        if (t.proxy == null || t.proxy.$i18n == null) throw qe(Me.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
        const M = i.value = t.proxy.$i18n.__composer;
        r === "global" ? (p.value = M.locale.value, m.value = M.fallbackLocale.value, v.value = M.messages.value, g.value = M.datetimeFormats.value, _.value = M.numberFormats.value) : c && ie(M)
    }), ae
}
const If = ["locale", "fallbackLocale", "availableLocales"],
    ls = ["t", "rt", "d", "n", "tm", "te"];

function Nf(t, r) {
    const o = Object.create(null);
    return If.forEach(c => {
        const i = Object.getOwnPropertyDescriptor(r, c);
        if (!i) throw qe(Me.UNEXPECTED_ERROR);
        const f = en(i.value) ? {
            get() {
                return i.value.value
            },
            set(p) {
                i.value.value = p
            }
        } : {
            get() {
                return i.get && i.get()
            }
        };
        Object.defineProperty(o, c, f)
    }), t.config.globalProperties.$i18n = o, ls.forEach(c => {
        const i = Object.getOwnPropertyDescriptor(r, c);
        if (!i || !i.value) throw qe(Me.UNEXPECTED_ERROR);
        Object.defineProperty(t.config.globalProperties, "$".concat(c), i)
    }), () => {
        delete t.config.globalProperties.$i18n, ls.forEach(c => {
            delete t.config.globalProperties["$".concat(c)]
        })
    }
}
lf();
__INTLIFY_JIT_COMPILATION__ ? Ua(Gl) : Ua(Yl);
ql(Jl);
Vl(Zs);
if (__INTLIFY_PROD_DEVTOOLS__) {
    const t = fn();
    t.__INTLIFY__ = !0, Hl(t.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__)
}
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
let li;
const Ir = t => li = t,
    fi = Symbol();

function Do(t) {
    return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function"
}
var jn;
(function(t) {
    t.direct = "direct", t.patchObject = "patch object", t.patchFunction = "patch function"
})(jn || (jn = {}));

function wp() {
    const t = xr(!0),
        r = t.run(() => St({}));
    let o = [],
        a = [];
    const c = Yo({
        install(i) {
            Ir(c), c._a = i, i.provide(fi, c), i.config.globalProperties.$pinia = c, a.forEach(f => o.push(f)), a = []
        },
        use(i) {
            return !this._a && !af ? a.push(i) : o.push(i), this
        },
        _p: o,
        _a: null,
        _e: t,
        _s: new Map,
        state: r
    });
    return c
}
const di = () => {};

function fs(t, r, o, a = di) {
    t.push(r);
    const c = () => {
        const i = t.indexOf(r);
        i > -1 && (t.splice(i, 1), a())
    };
    return !o && Vs() && Ys(c), c
}

function ln(t, ...r) {
    t.slice().forEach(o => {
        o(...r)
    })
}
const Lf = t => t();

function Mo(t, r) {
    t instanceof Map && r instanceof Map && r.forEach((o, a) => t.set(a, o)), t instanceof Set && r instanceof Set && r.forEach(t.add, t);
    for (const o in r) {
        if (!r.hasOwnProperty(o)) continue;
        const a = r[o],
            c = t[o];
        Do(c) && Do(a) && t.hasOwnProperty(o) && !en(a) && !Tr(a) ? t[o] = Mo(c, a) : t[o] = a
    }
    return t
}
const Ff = Symbol();

function Df(t) {
    return !Do(t) || !t.hasOwnProperty(Ff)
}
const {
    assign: Ut
} = Object;

function Mf(t) {
    return !!(en(t) && t.effect)
}

function jf(t, r, o, a) {
    const {
        state: c,
        actions: i,
        getters: f
    } = r, p = o.state.value[t];
    let m;

    function v() {
        p || (o.state.value[t] = c ? c() : {});
        const g = Qs(o.state.value[t]);
        return Ut(g, i, Object.keys(f || {}).reduce((_, T) => (_[T] = Yo(Ce(() => {
            Ir(o);
            const A = o._s.get(t);
            return f[T].call(A, A)
        })), _), {}))
    }
    return m = hi(t, v, r, o, a, !0), m
}

function hi(t, r, o = {}, a, c, i) {
    let f;
    const p = Ut({
            actions: {}
        }, o),
        m = {
            deep: !0
        };
    let v, g, _ = [],
        T = [],
        A;
    const B = a.state.value[t];
    !i && !B && (a.state.value[t] = {}), St({});
    let q;

    function re(fe) {
        let z;
        v = g = !1, typeof fe == "function" ? (fe(a.state.value[t]), z = {
            type: jn.patchFunction,
            storeId: t,
            events: A
        }) : (Mo(a.state.value[t], fe), z = {
            type: jn.patchObject,
            payload: fe,
            storeId: t,
            events: A
        });
        const Ae = q = Symbol();
        Jo().then(() => {
            q === Ae && (v = !0)
        }), g = !0, ln(_, z, a.state.value[t])
    }
    const oe = i ? function() {
        const {
            state: z
        } = o, Ae = z ? z() : {};
        this.$patch(Ve => {
            Ut(Ve, Ae)
        })
    } : di;

    function te() {
        f.stop(), _ = [], T = [], a._s.delete(t)
    }

    function Q(fe, z) {
        return function() {
            Ir(a);
            const Ae = Array.from(arguments),
                Ve = [],
                je = [];

            function Fe(Oe) {
                Ve.push(Oe)
            }

            function kt(Oe) {
                je.push(Oe)
            }
            ln(T, {
                args: Ae,
                name: fe,
                store: _e,
                after: Fe,
                onError: kt
            });
            let He;
            try {
                He = z.apply(this && this.$id === t ? this : _e, Ae)
            } catch (Oe) {
                throw ln(je, Oe), Oe
            }
            return He instanceof Promise ? He.then(Oe => (ln(Ve, Oe), Oe)).catch(Oe => (ln(je, Oe), Promise.reject(Oe))) : (ln(Ve, He), He)
        }
    }
    const ye = {
            _p: a,
            $id: t,
            $onAction: fs.bind(null, T),
            $patch: re,
            $reset: oe,
            $subscribe(fe, z = {}) {
                const Ae = fs(_, fe, z.detached, () => Ve()),
                    Ve = f.run(() => mn(() => a.state.value[t], je => {
                        (z.flush === "sync" ? g : v) && fe({
                            storeId: t,
                            type: jn.direct,
                            events: A
                        }, je)
                    }, Ut({}, m, z)));
                return Ae
            },
            $dispose: te
        },
        _e = Qo(ye);
    a._s.set(t, _e);
    const se = (a._a && a._a.runWithContext || Lf)(() => a._e.run(() => (f = xr()).run(r)));
    for (const fe in se) {
        const z = se[fe];
        if (en(z) && !Mf(z) || Tr(z)) i || (B && Df(z) && (en(z) ? z.value = B[fe] : Mo(z, B[fe])), a.state.value[t][fe] = z);
        else if (typeof z == "function") {
            const Ae = Q(fe, z);
            se[fe] = Ae, p.actions[fe] = z
        }
    }
    return Ut(_e, se), Ut(Zo(_e), se), Object.defineProperty(_e, "$state", {
        get: () => a.state.value[t],
        set: fe => {
            re(z => {
                Ut(z, fe)
            })
        }
    }), a._p.forEach(fe => {
        Ut(_e, f.run(() => fe({
            store: _e,
            app: a._a,
            pinia: a,
            options: p
        })))
    }), B && i && o.hydrate && o.hydrate(_e.$state, B), v = !0, g = !0, _e
}

function Ep(t, r, o) {
    let a, c;
    const i = typeof r == "function";
    typeof t == "string" ? (a = t, c = i ? o : r) : (c = t, a = t.id);

    function f(p, m) {
        const v = Hs();
        return p = p || (v ? gt(fi, null) : null), p && Ir(p), p = li, p._s.has(a) || (i ? hi(a, r, c, p) : jf(a, c, p)), p._s.get(a)
    }
    return f.$id = a, f
}

function Rp(t) {
    {
        t = Zo(t);
        const r = {};
        for (const o in t) {
            const a = t[o];
            (en(a) || Tr(a)) && (r[o] = Xs(t, o))
        }
        return r
    }
}
/*!
 * vue-router v4.4.0
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */
const dn = typeof document < "u";

function Bf(t) {
    return t.__esModule || t[Symbol.toStringTag] === "Module"
}
const Re = Object.assign;

function Eo(t, r) {
    const o = {};
    for (const a in r) {
        const c = r[a];
        o[a] = vt(c) ? c.map(t) : t(c)
    }
    return o
}
const Bn = () => {},
    vt = Array.isArray,
    pi = /#/g,
    Kf = /&/g,
    Uf = /\//g,
    qf = /=/g,
    Vf = /\?/g,
    mi = /\+/g,
    Hf = /%5B/g,
    $f = /%5D/g,
    yi = /%5E/g,
    Wf = /%60/g,
    gi = /%7B/g,
    zf = /%7C/g,
    vi = /%7D/g,
    Gf = /%20/g;

function oa(t) {
    return encodeURI("" + t).replace(zf, "|").replace(Hf, "[").replace($f, "]")
}

function Yf(t) {
    return oa(t).replace(gi, "{").replace(vi, "}").replace(yi, "^")
}

function jo(t) {
    return oa(t).replace(mi, "%2B").replace(Gf, "+").replace(pi, "%23").replace(Kf, "%26").replace(Wf, "`").replace(gi, "{").replace(vi, "}").replace(yi, "^")
}

function Jf(t) {
    return jo(t).replace(qf, "%3D")
}

function Xf(t) {
    return oa(t).replace(pi, "%23").replace(Vf, "%3F")
}

function Qf(t) {
    return t == null ? "" : Xf(t).replace(Uf, "%2F")
}

function qn(t) {
    try {
        return decodeURIComponent("" + t)
    } catch (r) {}
    return "" + t
}
const Zf = /\/$/,
    ed = t => t.replace(Zf, "");

function Ro(t, r, o = "/") {
    let a, c = {},
        i = "",
        f = "";
    const p = r.indexOf("#");
    let m = r.indexOf("?");
    return p < m && p >= 0 && (m = -1), m > -1 && (a = r.slice(0, m), i = r.slice(m + 1, p > -1 ? p : r.length), c = t(i)), p > -1 && (a = a || r.slice(0, p), f = r.slice(p, r.length)), a = od(a != null ? a : r, o), {
        fullPath: a + (i && "?") + i + f,
        path: a,
        query: c,
        hash: qn(f)
    }
}

function td(t, r) {
    const o = r.query ? t(r.query) : "";
    return r.path + (o && "?") + o + (r.hash || "")
}

function ds(t, r) {
    return !r || !t.toLowerCase().startsWith(r.toLowerCase()) ? t : t.slice(r.length) || "/"
}

function nd(t, r, o) {
    const a = r.matched.length - 1,
        c = o.matched.length - 1;
    return a > -1 && a === c && vn(r.matched[a], o.matched[c]) && bi(r.params, o.params) && t(r.query) === t(o.query) && r.hash === o.hash
}

function vn(t, r) {
    return (t.aliasOf || t) === (r.aliasOf || r)
}

function bi(t, r) {
    if (Object.keys(t).length !== Object.keys(r).length) return !1;
    for (const o in t)
        if (!rd(t[o], r[o])) return !1;
    return !0
}

function rd(t, r) {
    return vt(t) ? hs(t, r) : vt(r) ? hs(r, t) : t === r
}

function hs(t, r) {
    return vt(r) ? t.length === r.length && t.every((o, a) => o === r[a]) : t.length === 1 && t[0] === r
}

function od(t, r) {
    if (t.startsWith("/")) return t;
    if (!t) return r;
    const o = r.split("/"),
        a = t.split("/"),
        c = a[a.length - 1];
    (c === ".." || c === ".") && a.push("");
    let i = o.length - 1,
        f, p;
    for (f = 0; f < a.length; f++)
        if (p = a[f], p !== ".")
            if (p === "..") i > 1 && i--;
            else break;
    return o.slice(0, i).join("/") + "/" + a.slice(f).join("/")
}
const Bt = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
};
var Vn;
(function(t) {
    t.pop = "pop", t.push = "push"
})(Vn || (Vn = {}));
var Kn;
(function(t) {
    t.back = "back", t.forward = "forward", t.unknown = ""
})(Kn || (Kn = {}));

function ad(t) {
    if (!t)
        if (dn) {
            const r = document.querySelector("base");
            t = r && r.getAttribute("href") || "/", t = t.replace(/^\w+:\/\/[^\/]+/, "")
        } else t = "/";
    return t[0] !== "/" && t[0] !== "#" && (t = "/" + t), ed(t)
}
const sd = /^[^#]+#/;

function id(t, r) {
    return t.replace(sd, "#") + r
}

function ud(t, r) {
    const o = document.documentElement.getBoundingClientRect(),
        a = t.getBoundingClientRect();
    return {
        behavior: r.behavior,
        left: a.left - o.left - (r.left || 0),
        top: a.top - o.top - (r.top || 0)
    }
}
const Nr = () => ({
    left: window.scrollX,
    top: window.scrollY
});

function cd(t) {
    let r;
    if ("el" in t) {
        const o = t.el,
            a = typeof o == "string" && o.startsWith("#"),
            c = typeof o == "string" ? a ? document.getElementById(o.slice(1)) : document.querySelector(o) : o;
        if (!c) return;
        r = ud(c, t)
    } else r = t;
    "scrollBehavior" in document.documentElement.style ? window.scrollTo(r) : window.scrollTo(r.left != null ? r.left : window.scrollX, r.top != null ? r.top : window.scrollY)
}

function ps(t, r) {
    return (history.state ? history.state.position - r : -1) + t
}
const Bo = new Map;

function ld(t, r) {
    Bo.set(t, r)
}

function fd(t) {
    const r = Bo.get(t);
    return Bo.delete(t), r
}
let dd = () => location.protocol + "//" + location.host;

function _i(t, r) {
    const {
        pathname: o,
        search: a,
        hash: c
    } = r, i = t.indexOf("#");
    if (i > -1) {
        let p = c.includes(t.slice(i)) ? t.slice(i).length : 1,
            m = c.slice(p);
        return m[0] !== "/" && (m = "/" + m), ds(m, "")
    }
    return ds(o, t) + a + c
}

function hd(t, r, o, a) {
    let c = [],
        i = [],
        f = null;
    const p = ({
        state: T
    }) => {
        const A = _i(t, location),
            B = o.value,
            q = r.value;
        let re = 0;
        if (T) {
            if (o.value = A, r.value = T, f && f === B) {
                f = null;
                return
            }
            re = q ? T.position - q.position : 0
        } else a(A);
        c.forEach(oe => {
            oe(o.value, B, {
                delta: re,
                type: Vn.pop,
                direction: re ? re > 0 ? Kn.forward : Kn.back : Kn.unknown
            })
        })
    };

    function m() {
        f = o.value
    }

    function v(T) {
        c.push(T);
        const A = () => {
            const B = c.indexOf(T);
            B > -1 && c.splice(B, 1)
        };
        return i.push(A), A
    }

    function g() {
        const {
            history: T
        } = window;
        T.state && T.replaceState(Re({}, T.state, {
            scroll: Nr()
        }), "")
    }

    function _() {
        for (const T of i) T();
        i = [], window.removeEventListener("popstate", p), window.removeEventListener("beforeunload", g)
    }
    return window.addEventListener("popstate", p), window.addEventListener("beforeunload", g, {
        passive: !0
    }), {
        pauseListeners: m,
        listen: v,
        destroy: _
    }
}

function ms(t, r, o, a = !1, c = !1) {
    return {
        back: t,
        current: r,
        forward: o,
        replaced: a,
        position: window.history.length,
        scroll: c ? Nr() : null
    }
}

function pd(t) {
    const {
        history: r,
        location: o
    } = window, a = {
        value: _i(t, o)
    }, c = {
        value: r.state
    };
    c.value || i(a.value, {
        back: null,
        current: a.value,
        forward: null,
        position: r.length - 1,
        replaced: !0,
        scroll: null
    }, !0);

    function i(m, v, g) {
        const _ = t.indexOf("#"),
            T = _ > -1 ? (o.host && document.querySelector("base") ? t : t.slice(_)) + m : dd() + t + m;
        try {
            r[g ? "replaceState" : "pushState"](v, "", T), c.value = v
        } catch (A) {
            console.error(A), o[g ? "replace" : "assign"](T)
        }
    }

    function f(m, v) {
        const g = Re({}, r.state, ms(c.value.back, m, c.value.forward, !0), v, {
            position: c.value.position
        });
        i(m, g, !0), a.value = m
    }

    function p(m, v) {
        const g = Re({}, c.value, r.state, {
            forward: m,
            scroll: Nr()
        });
        i(g.current, g, !0);
        const _ = Re({}, ms(a.value, m, null), {
            position: g.position + 1
        }, v);
        i(m, _, !1), a.value = m
    }
    return {
        location: a,
        state: c,
        push: p,
        replace: f
    }
}

function Op(t) {
    t = ad(t);
    const r = pd(t),
        o = hd(t, r.state, r.location, r.replace);

    function a(i, f = !0) {
        f || o.pauseListeners(), history.go(i)
    }
    const c = Re({
        location: "",
        base: t,
        go: a,
        createHref: id.bind(null, t)
    }, r, o);
    return Object.defineProperty(c, "location", {
        enumerable: !0,
        get: () => r.location.value
    }), Object.defineProperty(c, "state", {
        enumerable: !0,
        get: () => r.state.value
    }), c
}

function md(t) {
    return typeof t == "string" || t && typeof t == "object"
}

function wi(t) {
    return typeof t == "string" || typeof t == "symbol"
}
const Ei = Symbol("");
var ys;
(function(t) {
    t[t.aborted = 4] = "aborted", t[t.cancelled = 8] = "cancelled", t[t.duplicated = 16] = "duplicated"
})(ys || (ys = {}));

function bn(t, r) {
    return Re(new Error, {
        type: t,
        [Ei]: !0
    }, r)
}

function It(t, r) {
    return t instanceof Error && Ei in t && (r == null || !!(t.type & r))
}
const gs = "[^/]+?",
    yd = {
        sensitive: !1,
        strict: !1,
        start: !0,
        end: !0
    },
    gd = /[.+*?^${}()[\]/\\]/g;

function vd(t, r) {
    const o = Re({}, yd, r),
        a = [];
    let c = o.start ? "^" : "";
    const i = [];
    for (const v of t) {
        const g = v.length ? [] : [90];
        o.strict && !v.length && (c += "/");
        for (let _ = 0; _ < v.length; _++) {
            const T = v[_];
            let A = 40 + (o.sensitive ? .25 : 0);
            if (T.type === 0) _ || (c += "/"), c += T.value.replace(gd, "\\$&"), A += 40;
            else if (T.type === 1) {
                const {
                    value: B,
                    repeatable: q,
                    optional: re,
                    regexp: oe
                } = T;
                i.push({
                    name: B,
                    repeatable: q,
                    optional: re
                });
                const te = oe || gs;
                if (te !== gs) {
                    A += 10;
                    try {
                        new RegExp("(".concat(te, ")"))
                    } catch (ye) {
                        throw new Error('Invalid custom RegExp for param "'.concat(B, '" (').concat(te, "): ") + ye.message)
                    }
                }
                let Q = q ? "((?:".concat(te, ")(?:/(?:").concat(te, "))*)") : "(".concat(te, ")");
                _ || (Q = re && v.length < 2 ? "(?:/".concat(Q, ")") : "/" + Q), re && (Q += "?"), c += Q, A += 20, re && (A += -8), q && (A += -20), te === ".*" && (A += -50)
            }
            g.push(A)
        }
        a.push(g)
    }
    if (o.strict && o.end) {
        const v = a.length - 1;
        a[v][a[v].length - 1] += .7000000000000001
    }
    o.strict || (c += "/?"), o.end ? c += "$" : o.strict && (c += "(?:/|$)");
    const f = new RegExp(c, o.sensitive ? "" : "i");

    function p(v) {
        const g = v.match(f),
            _ = {};
        if (!g) return null;
        for (let T = 1; T < g.length; T++) {
            const A = g[T] || "",
                B = i[T - 1];
            _[B.name] = A && B.repeatable ? A.split("/") : A
        }
        return _
    }

    function m(v) {
        let g = "",
            _ = !1;
        for (const T of t) {
            (!_ || !g.endsWith("/")) && (g += "/"), _ = !1;
            for (const A of T)
                if (A.type === 0) g += A.value;
                else if (A.type === 1) {
                const {
                    value: B,
                    repeatable: q,
                    optional: re
                } = A, oe = B in v ? v[B] : "";
                if (vt(oe) && !q) throw new Error('Provided param "'.concat(B, '" is an array but it is not repeatable (* or + modifiers)'));
                const te = vt(oe) ? oe.join("/") : oe;
                if (!te)
                    if (re) T.length < 2 && (g.endsWith("/") ? g = g.slice(0, -1) : _ = !0);
                    else throw new Error('Missing required param "'.concat(B, '"'));
                g += te
            }
        }
        return g || "/"
    }
    return {
        re: f,
        score: a,
        keys: i,
        parse: p,
        stringify: m
    }
}

function bd(t, r) {
    let o = 0;
    for (; o < t.length && o < r.length;) {
        const a = r[o] - t[o];
        if (a) return a;
        o++
    }
    return t.length < r.length ? t.length === 1 && t[0] === 80 ? -1 : 1 : t.length > r.length ? r.length === 1 && r[0] === 80 ? 1 : -1 : 0
}

function Ri(t, r) {
    let o = 0;
    const a = t.score,
        c = r.score;
    for (; o < a.length && o < c.length;) {
        const i = bd(a[o], c[o]);
        if (i) return i;
        o++
    }
    if (Math.abs(c.length - a.length) === 1) {
        if (vs(a)) return 1;
        if (vs(c)) return -1
    }
    return c.length - a.length
}

function vs(t) {
    const r = t[t.length - 1];
    return t.length > 0 && r[r.length - 1] < 0
}
const _d = {
        type: 0,
        value: ""
    },
    wd = /[a-zA-Z0-9_]/;

function Ed(t) {
    if (!t) return [
        []
    ];
    if (t === "/") return [
        [_d]
    ];
    if (!t.startsWith("/")) throw new Error('Invalid path "'.concat(t, '"'));

    function r(A) {
        throw new Error("ERR (".concat(o, ')/"').concat(v, '": ').concat(A))
    }
    let o = 0,
        a = o;
    const c = [];
    let i;

    function f() {
        i && c.push(i), i = []
    }
    let p = 0,
        m, v = "",
        g = "";

    function _() {
        v && (o === 0 ? i.push({
            type: 0,
            value: v
        }) : o === 1 || o === 2 || o === 3 ? (i.length > 1 && (m === "*" || m === "+") && r("A repeatable param (".concat(v, ") must be alone in its segment. eg: '/:ids+.")), i.push({
            type: 1,
            value: v,
            regexp: g,
            repeatable: m === "*" || m === "+",
            optional: m === "*" || m === "?"
        })) : r("Invalid state to consume buffer"), v = "")
    }

    function T() {
        v += m
    }
    for (; p < t.length;) {
        if (m = t[p++], m === "\\" && o !== 2) {
            a = o, o = 4;
            continue
        }
        switch (o) {
            case 0:
                m === "/" ? (v && _(), f()) : m === ":" ? (_(), o = 1) : T();
                break;
            case 4:
                T(), o = a;
                break;
            case 1:
                m === "(" ? o = 2 : wd.test(m) ? T() : (_(), o = 0, m !== "*" && m !== "?" && m !== "+" && p--);
                break;
            case 2:
                m === ")" ? g[g.length - 1] == "\\" ? g = g.slice(0, -1) + m : o = 3 : g += m;
                break;
            case 3:
                _(), o = 0, m !== "*" && m !== "?" && m !== "+" && p--, g = "";
                break;
            default:
                r("Unknown state");
                break
        }
    }
    return o === 2 && r('Unfinished custom RegExp for param "'.concat(v, '"')), _(), f(), c
}

function Rd(t, r, o) {
    const a = vd(Ed(t.path), o),
        c = Re(a, {
            record: t,
            parent: r,
            children: [],
            alias: []
        });
    return r && !c.record.aliasOf == !r.record.aliasOf && r.children.push(c), c
}

function Od(t, r) {
    const o = [],
        a = new Map;
    r = ws({
        strict: !1,
        end: !0,
        sensitive: !1
    }, r);

    function c(_) {
        return a.get(_)
    }

    function i(_, T, A) {
        const B = !A,
            q = Sd(_);
        q.aliasOf = A && A.record;
        const re = ws(r, _),
            oe = [q];
        if ("alias" in _) {
            const ye = typeof _.alias == "string" ? [_.alias] : _.alias;
            for (const _e of ye) oe.push(Re({}, q, {
                components: A ? A.record.components : q.components,
                path: _e,
                aliasOf: A ? A.record : q
            }))
        }
        let te, Q;
        for (const ye of oe) {
            const {
                path: _e
            } = ye;
            if (T && _e[0] !== "/") {
                const me = T.record.path,
                    se = me[me.length - 1] === "/" ? "" : "/";
                ye.path = T.record.path + (_e && se + _e)
            }
            if (te = Rd(ye, T, re), A ? A.alias.push(te) : (Q = Q || te, Q !== te && Q.alias.push(te), B && _.name && !_s(te) && f(_.name)), Oi(te) && m(te), q.children) {
                const me = q.children;
                for (let se = 0; se < me.length; se++) i(me[se], te, A && A.children[se])
            }
            A = A || te
        }
        return Q ? () => {
            f(Q)
        } : Bn
    }

    function f(_) {
        if (wi(_)) {
            const T = a.get(_);
            T && (a.delete(_), o.splice(o.indexOf(T), 1), T.children.forEach(f), T.alias.forEach(f))
        } else {
            const T = o.indexOf(_);
            T > -1 && (o.splice(T, 1), _.record.name && a.delete(_.record.name), _.children.forEach(f), _.alias.forEach(f))
        }
    }

    function p() {
        return o
    }

    function m(_) {
        const T = xd(_, o);
        o.splice(T, 0, _), _.record.name && !_s(_) && a.set(_.record.name, _)
    }

    function v(_, T) {
        let A, B = {},
            q, re;
        if ("name" in _ && _.name) {
            if (A = a.get(_.name), !A) throw bn(1, {
                location: _
            });
            re = A.record.name, B = Re(bs(T.params, A.keys.filter(Q => !Q.optional).concat(A.parent ? A.parent.keys.filter(Q => Q.optional) : []).map(Q => Q.name)), _.params && bs(_.params, A.keys.map(Q => Q.name))), q = A.stringify(B)
        } else if (_.path != null) q = _.path, A = o.find(Q => Q.re.test(q)), A && (B = A.parse(q), re = A.record.name);
        else {
            if (A = T.name ? a.get(T.name) : o.find(Q => Q.re.test(T.path)), !A) throw bn(1, {
                location: _,
                currentLocation: T
            });
            re = A.record.name, B = Re({}, T.params, _.params), q = A.stringify(B)
        }
        const oe = [];
        let te = A;
        for (; te;) oe.unshift(te.record), te = te.parent;
        return {
            name: re,
            path: q,
            params: B,
            matched: oe,
            meta: Pd(oe)
        }
    }
    t.forEach(_ => i(_));

    function g() {
        o.length = 0, a.clear()
    }
    return {
        addRoute: i,
        resolve: v,
        removeRoute: f,
        clearRoutes: g,
        getRoutes: p,
        getRecordMatcher: c
    }
}

function bs(t, r) {
    const o = {};
    for (const a of r) a in t && (o[a] = t[a]);
    return o
}

function Sd(t) {
    return {
        path: t.path,
        redirect: t.redirect,
        name: t.name,
        meta: t.meta || {},
        aliasOf: void 0,
        beforeEnter: t.beforeEnter,
        props: kd(t),
        children: t.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components" in t ? t.components || null : t.component && {
            default: t.component
        }
    }
}

function kd(t) {
    const r = {},
        o = t.props || !1;
    if ("component" in t) r.default = o;
    else
        for (const a in t.components) r[a] = typeof o == "object" ? o[a] : o;
    return r
}

function _s(t) {
    for (; t;) {
        if (t.record.aliasOf) return !0;
        t = t.parent
    }
    return !1
}

function Pd(t) {
    return t.reduce((r, o) => Re(r, o.meta), {})
}

function ws(t, r) {
    const o = {};
    for (const a in t) o[a] = a in r ? r[a] : t[a];
    return o
}

function xd(t, r) {
    let o = 0,
        a = r.length;
    for (; o !== a;) {
        const i = o + a >> 1;
        Ri(t, r[i]) < 0 ? a = i : o = i + 1
    }
    const c = Td(t);
    return c && (a = r.lastIndexOf(c, a - 1)), a
}

function Td(t) {
    let r = t;
    for (; r = r.parent;)
        if (Oi(r) && Ri(t, r) === 0) return r
}

function Oi({
    record: t
}) {
    return !!(t.name || t.components && Object.keys(t.components).length || t.redirect)
}

function Cd(t) {
    const r = {};
    if (t === "" || t === "?") return r;
    const a = (t[0] === "?" ? t.slice(1) : t).split("&");
    for (let c = 0; c < a.length; ++c) {
        const i = a[c].replace(mi, " "),
            f = i.indexOf("="),
            p = qn(f < 0 ? i : i.slice(0, f)),
            m = f < 0 ? null : qn(i.slice(f + 1));
        if (p in r) {
            let v = r[p];
            vt(v) || (v = r[p] = [v]), v.push(m)
        } else r[p] = m
    }
    return r
}

function Es(t) {
    let r = "";
    for (let o in t) {
        const a = t[o];
        if (o = Jf(o), a == null) {
            a !== void 0 && (r += (r.length ? "&" : "") + o);
            continue
        }(vt(a) ? a.map(i => i && jo(i)) : [a && jo(a)]).forEach(i => {
            i !== void 0 && (r += (r.length ? "&" : "") + o, i != null && (r += "=" + i))
        })
    }
    return r
}

function Ad(t) {
    const r = {};
    for (const o in t) {
        const a = t[o];
        a !== void 0 && (r[o] = vt(a) ? a.map(c => c == null ? null : "" + c) : a == null ? a : "" + a)
    }
    return r
}
const Si = Symbol(""),
    Rs = Symbol(""),
    Lr = Symbol(""),
    aa = Symbol(""),
    Ko = Symbol("");

function Dn() {
    let t = [];

    function r(a) {
        return t.push(a), () => {
            const c = t.indexOf(a);
            c > -1 && t.splice(c, 1)
        }
    }

    function o() {
        t = []
    }
    return {
        add: r,
        list: () => t.slice(),
        reset: o
    }
}

function Id(t, r, o) {
    const a = () => {
        t[r].delete(o)
    };
    Xo(a), zs(a), $s(() => {
        t[r].add(o)
    }), t[r].add(o)
}

function Sp(t) {
    const r = gt(Si, {}).value;
    r && Id(r, "leaveGuards", t)
}

function qt(t, r, o, a, c, i = f => f()) {
    const f = a && (a.enterCallbacks[c] = a.enterCallbacks[c] || []);
    return () => new Promise((p, m) => {
        const v = T => {
                T === !1 ? m(bn(4, {
                    from: o,
                    to: r
                })) : T instanceof Error ? m(T) : md(T) ? m(bn(2, {
                    from: r,
                    to: T
                })) : (f && a.enterCallbacks[c] === f && typeof T == "function" && f.push(T), p())
            },
            g = i(() => t.call(a && a.instances[c], r, o, v));
        let _ = Promise.resolve(g);
        t.length < 3 && (_ = _.then(v)), _.catch(T => m(T))
    })
}

function Oo(t, r, o, a, c = i => i()) {
    const i = [];
    for (const f of t)
        for (const p in f.components) {
            let m = f.components[p];
            if (!(r !== "beforeRouteEnter" && !f.instances[p]))
                if (Nd(m)) {
                    const g = (m.__vccOpts || m)[r];
                    g && i.push(qt(g, o, a, f, p, c))
                } else {
                    let v = m();
                    i.push(() => v.then(g => {
                        if (!g) return Promise.reject(new Error("Couldn't resolve component \"".concat(p, '" at "').concat(f.path, '"')));
                        const _ = Bf(g) ? g.default : g;
                        f.components[p] = _;
                        const A = (_.__vccOpts || _)[r];
                        return A && qt(A, o, a, f, p, c)()
                    }))
                }
        }
    return i
}

function Nd(t) {
    return typeof t == "object" || "displayName" in t || "props" in t || "__vccOpts" in t
}

function Os(t) {
    const r = gt(Lr),
        o = gt(aa),
        a = Ce(() => {
            const m = hn(t.to);
            return r.resolve(m)
        }),
        c = Ce(() => {
            const {
                matched: m
            } = a.value, {
                length: v
            } = m, g = m[v - 1], _ = o.matched;
            if (!g || !_.length) return -1;
            const T = _.findIndex(vn.bind(null, g));
            if (T > -1) return T;
            const A = Ss(m[v - 2]);
            return v > 1 && Ss(g) === A && _[_.length - 1].path !== A ? _.findIndex(vn.bind(null, m[v - 2])) : T
        }),
        i = Ce(() => c.value > -1 && Md(o.params, a.value.params)),
        f = Ce(() => c.value > -1 && c.value === o.matched.length - 1 && bi(o.params, a.value.params));

    function p(m = {}) {
        return Dd(m) ? r[hn(t.replace) ? "replace" : "push"](hn(t.to)).catch(Bn) : Promise.resolve()
    }
    return {
        route: a,
        href: Ce(() => a.value.href),
        isActive: i,
        isExactActive: f,
        navigate: p
    }
}
const Ld = _n({
        name: "RouterLink",
        compatConfig: {
            MODE: 3
        },
        props: {
            to: {
                type: [String, Object],
                required: !0
            },
            replace: Boolean,
            activeClass: String,
            exactActiveClass: String,
            custom: Boolean,
            ariaCurrentValue: {
                type: String,
                default: "page"
            }
        },
        useLink: Os,
        setup(t, {
            slots: r
        }) {
            const o = Qo(Os(t)),
                {
                    options: a
                } = gt(Lr),
                c = Ce(() => ({
                    [ks(t.activeClass, a.linkActiveClass, "router-link-active")]: o.isActive,
                    [ks(t.exactActiveClass, a.linkExactActiveClass, "router-link-exact-active")]: o.isExactActive
                }));
            return () => {
                const i = r.default && r.default(o);
                return t.custom ? i : $n("a", {
                    "aria-current": o.isExactActive ? t.ariaCurrentValue : null,
                    href: o.href,
                    onClick: o.navigate,
                    class: c.value
                }, i)
            }
        }
    }),
    Fd = Ld;

function Dd(t) {
    if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && !(t.button !== void 0 && t.button !== 0)) {
        if (t.currentTarget && t.currentTarget.getAttribute) {
            const r = t.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(r)) return
        }
        return t.preventDefault && t.preventDefault(), !0
    }
}

function Md(t, r) {
    for (const o in r) {
        const a = r[o],
            c = t[o];
        if (typeof a == "string") {
            if (a !== c) return !1
        } else if (!vt(c) || c.length !== a.length || a.some((i, f) => i !== c[f])) return !1
    }
    return !0
}

function Ss(t) {
    return t ? t.aliasOf ? t.aliasOf.path : t.path : ""
}
const ks = (t, r, o) => t != null ? t : r != null ? r : o,
    jd = _n({
        name: "RouterView",
        inheritAttrs: !1,
        props: {
            name: {
                type: String,
                default: "default"
            },
            route: Object
        },
        compatConfig: {
            MODE: 3
        },
        setup(t, {
            attrs: r,
            slots: o
        }) {
            const a = gt(Ko),
                c = Ce(() => t.route || a.value),
                i = gt(Rs, 0),
                f = Ce(() => {
                    let v = hn(i);
                    const {
                        matched: g
                    } = c.value;
                    let _;
                    for (;
                        (_ = g[v]) && !_.components;) v++;
                    return v
                }),
                p = Ce(() => c.value.matched[f.value]);
            _r(Rs, Ce(() => f.value + 1)), _r(Si, p), _r(Ko, c);
            const m = St();
            return mn(() => [m.value, p.value, t.name], ([v, g, _], [T, A, B]) => {
                g && (g.instances[_] = v, A && A !== g && v && v === T && (g.leaveGuards.size || (g.leaveGuards = A.leaveGuards), g.updateGuards.size || (g.updateGuards = A.updateGuards))), v && g && (!A || !vn(g, A) || !T) && (g.enterCallbacks[_] || []).forEach(q => q(v))
            }, {
                flush: "post"
            }), () => {
                const v = c.value,
                    g = t.name,
                    _ = p.value,
                    T = _ && _.components[g];
                if (!T) return Ps(o.default, {
                    Component: T,
                    route: v
                });
                const A = _.props[g],
                    B = A ? A === !0 ? v.params : typeof A == "function" ? A(v) : A : null,
                    re = $n(T, Re({}, B, r, {
                        onVnodeUnmounted: oe => {
                            oe.component.isUnmounted && (_.instances[g] = null)
                        },
                        ref: m
                    }));
                return Ps(o.default, {
                    Component: re,
                    route: v
                }) || re
            }
        }
    });

function Ps(t, r) {
    if (!t) return null;
    const o = t(r);
    return o.length === 1 ? o[0] : o
}
const Bd = jd;

function kp(t) {
    const r = Od(t.routes, t),
        o = t.parseQuery || Cd,
        a = t.stringifyQuery || Es,
        c = t.history,
        i = Dn(),
        f = Dn(),
        p = Dn(),
        m = Cr(Bt);
    let v = Bt;
    dn && t.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
    const g = Eo.bind(null, K => "" + K),
        _ = Eo.bind(null, Qf),
        T = Eo.bind(null, qn);

    function A(K, X) {
        let F, Z;
        return wi(K) ? (F = r.getRecordMatcher(K), Z = X) : Z = K, r.addRoute(Z, F)
    }

    function B(K) {
        const X = r.getRecordMatcher(K);
        X && r.removeRoute(X)
    }

    function q() {
        return r.getRoutes().map(K => K.record)
    }

    function re(K) {
        return !!r.getRecordMatcher(K)
    }

    function oe(K, X) {
        if (X = Re({}, X || m.value), typeof K == "string") {
            const M = Ro(o, K, X.path),
                ne = r.resolve({
                    path: M.path
                }, X),
                Et = c.createHref(M.fullPath);
            return Re(M, ne, {
                params: T(ne.params),
                hash: qn(M.hash),
                redirectedFrom: void 0,
                href: Et
            })
        }
        let F;
        if (K.path != null) F = Re({}, K, {
            path: Ro(o, K.path, X.path).path
        });
        else {
            const M = Re({}, K.params);
            for (const ne in M) M[ne] == null && delete M[ne];
            F = Re({}, K, {
                params: _(M)
            }), X.params = _(X.params)
        }
        const Z = r.resolve(F, X),
            ge = K.hash || "";
        Z.params = g(T(Z.params));
        const ae = td(a, Re({}, K, {
                hash: Yf(ge),
                path: Z.path
            })),
            ie = c.createHref(ae);
        return Re({
            fullPath: ae,
            hash: ge,
            query: a === Es ? Ad(K.query) : K.query || {}
        }, Z, {
            redirectedFrom: void 0,
            href: ie
        })
    }

    function te(K) {
        return typeof K == "string" ? Ro(o, K, m.value.path) : Re({}, K)
    }

    function Q(K, X) {
        if (v !== K) return bn(8, {
            from: X,
            to: K
        })
    }

    function ye(K) {
        return se(K)
    }

    function _e(K) {
        return ye(Re(te(K), {
            replace: !0
        }))
    }

    function me(K) {
        const X = K.matched[K.matched.length - 1];
        if (X && X.redirect) {
            const {
                redirect: F
            } = X;
            let Z = typeof F == "function" ? F(K) : F;
            return typeof Z == "string" && (Z = Z.includes("?") || Z.includes("#") ? Z = te(Z) : {
                path: Z
            }, Z.params = {}), Re({
                query: K.query,
                hash: K.hash,
                params: Z.path != null ? {} : K.params
            }, Z)
        }
    }

    function se(K, X) {
        const F = v = oe(K),
            Z = m.value,
            ge = K.state,
            ae = K.force,
            ie = K.replace === !0,
            M = me(F);
        if (M) return se(Re(te(M), {
            state: typeof M == "object" ? Re({}, ge, M.state) : ge,
            force: ae,
            replace: ie
        }), X || F);
        const ne = F;
        ne.redirectedFrom = X;
        let Et;
        return !ae && nd(a, Z, F) && (Et = bn(16, {
            to: ne,
            from: Z
        }), ze(Z, Z, !0, !1)), (Et ? Promise.resolve(Et) : Ae(ne, Z)).catch(Be => It(Be) ? It(Be, 2) ? Be : $e(Be) : Xe(Be, ne, Z)).then(Be => {
            if (Be) {
                if (It(Be, 2)) return se(Re({
                    replace: ie
                }, te(Be.to), {
                    state: typeof Be.to == "object" ? Re({}, ge, Be.to.state) : ge,
                    force: ae
                }), X || ne)
            } else Be = je(ne, Z, !0, ie, ge);
            return Ve(ne, Z, Be), Be
        })
    }

    function fe(K, X) {
        const F = Q(K, X);
        return F ? Promise.reject(F) : Promise.resolve()
    }

    function z(K) {
        const X = lt.values().next().value;
        return X && typeof X.runWithContext == "function" ? X.runWithContext(K) : K()
    }

    function Ae(K, X) {
        let F;
        const [Z, ge, ae] = Kd(K, X);
        F = Oo(Z.reverse(), "beforeRouteLeave", K, X);
        for (const M of Z) M.leaveGuards.forEach(ne => {
            F.push(qt(ne, K, X))
        });
        const ie = fe.bind(null, K, X);
        return F.push(ie), We(F).then(() => {
            F = [];
            for (const M of i.list()) F.push(qt(M, K, X));
            return F.push(ie), We(F)
        }).then(() => {
            F = Oo(ge, "beforeRouteUpdate", K, X);
            for (const M of ge) M.updateGuards.forEach(ne => {
                F.push(qt(ne, K, X))
            });
            return F.push(ie), We(F)
        }).then(() => {
            F = [];
            for (const M of ae)
                if (M.beforeEnter)
                    if (vt(M.beforeEnter))
                        for (const ne of M.beforeEnter) F.push(qt(ne, K, X));
                    else F.push(qt(M.beforeEnter, K, X));
            return F.push(ie), We(F)
        }).then(() => (K.matched.forEach(M => M.enterCallbacks = {}), F = Oo(ae, "beforeRouteEnter", K, X, z), F.push(ie), We(F))).then(() => {
            F = [];
            for (const M of f.list()) F.push(qt(M, K, X));
            return F.push(ie), We(F)
        }).catch(M => It(M, 8) ? M : Promise.reject(M))
    }

    function Ve(K, X, F) {
        p.list().forEach(Z => z(() => Z(K, X, F)))
    }

    function je(K, X, F, Z, ge) {
        const ae = Q(K, X);
        if (ae) return ae;
        const ie = X === Bt,
            M = dn ? history.state : {};
        F && (Z || ie ? c.replace(K.fullPath, Re({
            scroll: ie && M && M.scroll
        }, ge)) : c.push(K.fullPath, ge)), m.value = K, ze(K, X, F, ie), $e()
    }
    let Fe;

    function kt() {
        Fe || (Fe = c.listen((K, X, F) => {
            if (!ft.listening) return;
            const Z = oe(K),
                ge = me(Z);
            if (ge) {
                se(Re(ge, {
                    replace: !0
                }), Z).catch(Bn);
                return
            }
            v = Z;
            const ae = m.value;
            dn && ld(ps(ae.fullPath, F.delta), Nr()), Ae(Z, ae).catch(ie => It(ie, 12) ? ie : It(ie, 2) ? (se(ie.to, Z).then(M => {
                It(M, 20) && !F.delta && F.type === Vn.pop && c.go(-1, !1)
            }).catch(Bn), Promise.reject()) : (F.delta && c.go(-F.delta, !1), Xe(ie, Z, ae))).then(ie => {
                ie = ie || je(Z, ae, !1), ie && (F.delta && !It(ie, 8) ? c.go(-F.delta, !1) : F.type === Vn.pop && It(ie, 20) && c.go(-1, !1)), Ve(Z, ae, ie)
            }).catch(Bn)
        }))
    }
    let He = Dn(),
        Oe = Dn(),
        _t;

    function Xe(K, X, F) {
        $e(K);
        const Z = Oe.list();
        return Z.length ? Z.forEach(ge => ge(K, X, F)) : console.error(K), Promise.reject(K)
    }

    function at() {
        return _t && m.value !== Bt ? Promise.resolve() : new Promise((K, X) => {
            He.add([K, X])
        })
    }

    function $e(K) {
        return _t || (_t = !K, kt(), He.list().forEach(([X, F]) => K ? F(K) : X()), He.reset()), K
    }

    function ze(K, X, F, Z) {
        const {
            scrollBehavior: ge
        } = t;
        if (!dn || !ge) return Promise.resolve();
        const ae = !F && fd(ps(K.fullPath, 0)) || (Z || !F) && history.state && history.state.scroll || null;
        return Jo().then(() => ge(K, X, ae)).then(ie => ie && cd(ie)).catch(ie => Xe(ie, K, X))
    }
    const wt = K => c.go(K);
    let Ze;
    const lt = new Set,
        ft = {
            currentRoute: m,
            listening: !0,
            addRoute: A,
            removeRoute: B,
            clearRoutes: r.clearRoutes,
            hasRoute: re,
            getRoutes: q,
            resolve: oe,
            options: t,
            push: ye,
            replace: _e,
            go: wt,
            back: () => wt(-1),
            forward: () => wt(1),
            beforeEach: i.add,
            beforeResolve: f.add,
            afterEach: p.add,
            onError: Oe.add,
            isReady: at,
            install(K) {
                const X = this;
                K.component("RouterLink", Fd), K.component("RouterView", Bd), K.config.globalProperties.$router = X, Object.defineProperty(K.config.globalProperties, "$route", {
                    enumerable: !0,
                    get: () => hn(m)
                }), dn && !Ze && m.value === Bt && (Ze = !0, ye(c.location).catch(ge => {}));
                const F = {};
                for (const ge in Bt) Object.defineProperty(F, ge, {
                    get: () => m.value[ge],
                    enumerable: !0
                });
                K.provide(Lr, X), K.provide(aa, Js(F)), K.provide(Ko, m);
                const Z = K.unmount;
                lt.add(K), K.unmount = function() {
                    lt.delete(K), lt.size < 1 && (v = Bt, Fe && Fe(), Fe = null, m.value = Bt, Ze = !1, _t = !1), Z()
                }
            }
        };

    function We(K) {
        return K.reduce((X, F) => X.then(() => z(F)), Promise.resolve())
    }
    return ft
}

function Kd(t, r) {
    const o = [],
        a = [],
        c = [],
        i = Math.max(r.matched.length, t.matched.length);
    for (let f = 0; f < i; f++) {
        const p = r.matched[f];
        p && (t.matched.find(v => vn(v, p)) ? a.push(p) : o.push(p));
        const m = t.matched[f];
        m && (r.matched.find(v => vn(v, m)) || c.push(m))
    }
    return [o, a, c]
}

function Pp() {
    return gt(Lr)
}

function xp(t) {
    return gt(aa)
}

function ki(t, r) {
    return function() {
        return t.apply(r, arguments)
    }
}
const {
    toString: Ud
} = Object.prototype, {
    getPrototypeOf: sa
} = Object, Fr = (t => r => {
    const o = Ud.call(r);
    return t[o] || (t[o] = o.slice(8, -1).toLowerCase())
})(Object.create(null)), bt = t => (t = t.toLowerCase(), r => Fr(r) === t), Dr = t => r => typeof r === t, {
    isArray: wn
} = Array, Hn = Dr("undefined");

function qd(t) {
    return t !== null && !Hn(t) && t.constructor !== null && !Hn(t.constructor) && ct(t.constructor.isBuffer) && t.constructor.isBuffer(t)
}
const Pi = bt("ArrayBuffer");

function Vd(t) {
    let r;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? r = ArrayBuffer.isView(t) : r = t && t.buffer && Pi(t.buffer), r
}
const Hd = Dr("string"),
    ct = Dr("function"),
    xi = Dr("number"),
    Mr = t => t !== null && typeof t == "object",
    $d = t => t === !0 || t === !1,
    Er = t => {
        if (Fr(t) !== "object") return !1;
        const r = sa(t);
        return (r === null || r === Object.prototype || Object.getPrototypeOf(r) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
    },
    Wd = bt("Date"),
    zd = bt("File"),
    Gd = bt("Blob"),
    Yd = bt("FileList"),
    Jd = t => Mr(t) && ct(t.pipe),
    Xd = t => {
        let r;
        return t && (typeof FormData == "function" && t instanceof FormData || ct(t.append) && ((r = Fr(t)) === "formdata" || r === "object" && ct(t.toString) && t.toString() === "[object FormData]"))
    },
    Qd = bt("URLSearchParams"),
    [Zd, eh, th, nh] = ["ReadableStream", "Request", "Response", "Headers"].map(bt),
    rh = t => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");

function Wn(t, r, {
    allOwnKeys: o = !1
} = {}) {
    if (t === null || typeof t > "u") return;
    let a, c;
    if (typeof t != "object" && (t = [t]), wn(t))
        for (a = 0, c = t.length; a < c; a++) r.call(null, t[a], a, t);
    else {
        const i = o ? Object.getOwnPropertyNames(t) : Object.keys(t),
            f = i.length;
        let p;
        for (a = 0; a < f; a++) p = i[a], r.call(null, t[p], p, t)
    }
}

function Ti(t, r) {
    r = r.toLowerCase();
    const o = Object.keys(t);
    let a = o.length,
        c;
    for (; a-- > 0;)
        if (c = o[a], r === c.toLowerCase()) return c;
    return null
}
const Ci = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global,
    Ai = t => !Hn(t) && t !== Ci;

function Uo() {
    const {
        caseless: t
    } = Ai(this) && this || {}, r = {}, o = (a, c) => {
        const i = t && Ti(r, c) || c;
        Er(r[i]) && Er(a) ? r[i] = Uo(r[i], a) : Er(a) ? r[i] = Uo({}, a) : wn(a) ? r[i] = a.slice() : r[i] = a
    };
    for (let a = 0, c = arguments.length; a < c; a++) arguments[a] && Wn(arguments[a], o);
    return r
}
const oh = (t, r, o, {
        allOwnKeys: a
    } = {}) => (Wn(r, (c, i) => {
        o && ct(c) ? t[i] = ki(c, o) : t[i] = c
    }, {
        allOwnKeys: a
    }), t),
    ah = t => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t),
    sh = (t, r, o, a) => {
        t.prototype = Object.create(r.prototype, a), t.prototype.constructor = t, Object.defineProperty(t, "super", {
            value: r.prototype
        }), o && Object.assign(t.prototype, o)
    },
    ih = (t, r, o, a) => {
        let c, i, f;
        const p = {};
        if (r = r || {}, t == null) return r;
        do {
            for (c = Object.getOwnPropertyNames(t), i = c.length; i-- > 0;) f = c[i], (!a || a(f, t, r)) && !p[f] && (r[f] = t[f], p[f] = !0);
            t = o !== !1 && sa(t)
        } while (t && (!o || o(t, r)) && t !== Object.prototype);
        return r
    },
    uh = (t, r, o) => {
        t = String(t), (o === void 0 || o > t.length) && (o = t.length), o -= r.length;
        const a = t.indexOf(r, o);
        return a !== -1 && a === o
    },
    ch = t => {
        if (!t) return null;
        if (wn(t)) return t;
        let r = t.length;
        if (!xi(r)) return null;
        const o = new Array(r);
        for (; r-- > 0;) o[r] = t[r];
        return o
    },
    lh = (t => r => t && r instanceof t)(typeof Uint8Array < "u" && sa(Uint8Array)),
    fh = (t, r) => {
        const a = (t && t[Symbol.iterator]).call(t);
        let c;
        for (;
            (c = a.next()) && !c.done;) {
            const i = c.value;
            r.call(t, i[0], i[1])
        }
    },
    dh = (t, r) => {
        let o;
        const a = [];
        for (;
            (o = t.exec(r)) !== null;) a.push(o);
        return a
    },
    hh = bt("HTMLFormElement"),
    ph = t => t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(o, a, c) {
        return a.toUpperCase() + c
    }),
    xs = (({
        hasOwnProperty: t
    }) => (r, o) => t.call(r, o))(Object.prototype),
    mh = bt("RegExp"),
    Ii = (t, r) => {
        const o = Object.getOwnPropertyDescriptors(t),
            a = {};
        Wn(o, (c, i) => {
            let f;
            (f = r(c, i, t)) !== !1 && (a[i] = f || c)
        }), Object.defineProperties(t, a)
    },
    yh = t => {
        Ii(t, (r, o) => {
            if (ct(t) && ["arguments", "caller", "callee"].indexOf(o) !== -1) return !1;
            const a = t[o];
            if (ct(a)) {
                if (r.enumerable = !1, "writable" in r) {
                    r.writable = !1;
                    return
                }
                r.set || (r.set = () => {
                    throw Error("Can not rewrite read-only method '" + o + "'")
                })
            }
        })
    },
    gh = (t, r) => {
        const o = {},
            a = c => {
                c.forEach(i => {
                    o[i] = !0
                })
            };
        return wn(t) ? a(t) : a(String(t).split(r)), o
    },
    vh = () => {},
    bh = (t, r) => t != null && Number.isFinite(t = +t) ? t : r,
    So = "abcdefghijklmnopqrstuvwxyz",
    Ts = "0123456789",
    Ni = {
        DIGIT: Ts,
        ALPHA: So,
        ALPHA_DIGIT: So + So.toUpperCase() + Ts
    },
    _h = (t = 16, r = Ni.ALPHA_DIGIT) => {
        let o = "";
        const {
            length: a
        } = r;
        for (; t--;) o += r[Math.random() * a | 0];
        return o
    };

function wh(t) {
    return !!(t && ct(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator])
}
const Eh = t => {
        const r = new Array(10),
            o = (a, c) => {
                if (Mr(a)) {
                    if (r.indexOf(a) >= 0) return;
                    if (!("toJSON" in a)) {
                        r[c] = a;
                        const i = wn(a) ? [] : {};
                        return Wn(a, (f, p) => {
                            const m = o(f, c + 1);
                            !Hn(m) && (i[p] = m)
                        }), r[c] = void 0, i
                    }
                }
                return a
            };
        return o(t, 0)
    },
    Rh = bt("AsyncFunction"),
    Oh = t => t && (Mr(t) || ct(t)) && ct(t.then) && ct(t.catch),
    L = {
        isArray: wn,
        isArrayBuffer: Pi,
        isBuffer: qd,
        isFormData: Xd,
        isArrayBufferView: Vd,
        isString: Hd,
        isNumber: xi,
        isBoolean: $d,
        isObject: Mr,
        isPlainObject: Er,
        isReadableStream: Zd,
        isRequest: eh,
        isResponse: th,
        isHeaders: nh,
        isUndefined: Hn,
        isDate: Wd,
        isFile: zd,
        isBlob: Gd,
        isRegExp: mh,
        isFunction: ct,
        isStream: Jd,
        isURLSearchParams: Qd,
        isTypedArray: lh,
        isFileList: Yd,
        forEach: Wn,
        merge: Uo,
        extend: oh,
        trim: rh,
        stripBOM: ah,
        inherits: sh,
        toFlatObject: ih,
        kindOf: Fr,
        kindOfTest: bt,
        endsWith: uh,
        toArray: ch,
        forEachEntry: fh,
        matchAll: dh,
        isHTMLForm: hh,
        hasOwnProperty: xs,
        hasOwnProp: xs,
        reduceDescriptors: Ii,
        freezeMethods: yh,
        toObjectSet: gh,
        toCamelCase: ph,
        noop: vh,
        toFiniteNumber: bh,
        findKey: Ti,
        global: Ci,
        isContextDefined: Ai,
        ALPHABET: Ni,
        generateString: _h,
        isSpecCompliantForm: wh,
        toJSONObject: Eh,
        isAsyncFn: Rh,
        isThenable: Oh
    };

function le(t, r, o, a, c) {
    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", r && (this.code = r), o && (this.config = o), a && (this.request = a), c && (this.response = c)
}
L.inherits(le, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: L.toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        }
    }
});
const Li = le.prototype,
    Fi = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(t => {
    Fi[t] = {
        value: t
    }
});
Object.defineProperties(le, Fi);
Object.defineProperty(Li, "isAxiosError", {
    value: !0
});
le.from = (t, r, o, a, c, i) => {
    const f = Object.create(Li);
    return L.toFlatObject(t, f, function(m) {
        return m !== Error.prototype
    }, p => p !== "isAxiosError"), le.call(f, t.message, r, o, a, c), f.cause = t, f.name = t.name, i && Object.assign(f, i), f
};
const Sh = null;

function qo(t) {
    return L.isPlainObject(t) || L.isArray(t)
}

function Di(t) {
    return L.endsWith(t, "[]") ? t.slice(0, -2) : t
}

function Cs(t, r, o) {
    return t ? t.concat(r).map(function(c, i) {
        return c = Di(c), !o && i ? "[" + c + "]" : c
    }).join(o ? "." : "") : r
}

function kh(t) {
    return L.isArray(t) && !t.some(qo)
}
const Ph = L.toFlatObject(L, {}, null, function(r) {
    return /^is[A-Z]/.test(r)
});

function jr(t, r, o) {
    if (!L.isObject(t)) throw new TypeError("target must be an object");
    r = r || new FormData, o = L.toFlatObject(o, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(q, re) {
        return !L.isUndefined(re[q])
    });
    const a = o.metaTokens,
        c = o.visitor || g,
        i = o.dots,
        f = o.indexes,
        m = (o.Blob || typeof Blob < "u" && Blob) && L.isSpecCompliantForm(r);
    if (!L.isFunction(c)) throw new TypeError("visitor must be a function");

    function v(B) {
        if (B === null) return "";
        if (L.isDate(B)) return B.toISOString();
        if (!m && L.isBlob(B)) throw new le("Blob is not supported. Use a Buffer instead.");
        return L.isArrayBuffer(B) || L.isTypedArray(B) ? m && typeof Blob == "function" ? new Blob([B]) : Buffer.from(B) : B
    }

    function g(B, q, re) {
        let oe = B;
        if (B && !re && typeof B == "object") {
            if (L.endsWith(q, "{}")) q = a ? q : q.slice(0, -2), B = JSON.stringify(B);
            else if (L.isArray(B) && kh(B) || (L.isFileList(B) || L.endsWith(q, "[]")) && (oe = L.toArray(B))) return q = Di(q), oe.forEach(function(Q, ye) {
                !(L.isUndefined(Q) || Q === null) && r.append(f === !0 ? Cs([q], ye, i) : f === null ? q : q + "[]", v(Q))
            }), !1
        }
        return qo(B) ? !0 : (r.append(Cs(re, q, i), v(B)), !1)
    }
    const _ = [],
        T = Object.assign(Ph, {
            defaultVisitor: g,
            convertValue: v,
            isVisitable: qo
        });

    function A(B, q) {
        if (!L.isUndefined(B)) {
            if (_.indexOf(B) !== -1) throw Error("Circular reference detected in " + q.join("."));
            _.push(B), L.forEach(B, function(oe, te) {
                (!(L.isUndefined(oe) || oe === null) && c.call(r, oe, L.isString(te) ? te.trim() : te, q, T)) === !0 && A(oe, q ? q.concat(te) : [te])
            }), _.pop()
        }
    }
    if (!L.isObject(t)) throw new TypeError("data must be an object");
    return A(t), r
}

function As(t) {
    const r = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(a) {
        return r[a]
    })
}

function ia(t, r) {
    this._pairs = [], t && jr(t, this, r)
}
const Mi = ia.prototype;
Mi.append = function(r, o) {
    this._pairs.push([r, o])
};
Mi.toString = function(r) {
    const o = r ? function(a) {
        return r.call(this, a, As)
    } : As;
    return this._pairs.map(function(c) {
        return o(c[0]) + "=" + o(c[1])
    }, "").join("&")
};

function xh(t) {
    return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}

function ji(t, r, o) {
    if (!r) return t;
    const a = o && o.encode || xh,
        c = o && o.serialize;
    let i;
    if (c ? i = c(r, o) : i = L.isURLSearchParams(r) ? r.toString() : new ia(r, o).toString(a), i) {
        const f = t.indexOf("#");
        f !== -1 && (t = t.slice(0, f)), t += (t.indexOf("?") === -1 ? "?" : "&") + i
    }
    return t
}
class Is {
    constructor() {
        this.handlers = []
    }
    use(r, o, a) {
        return this.handlers.push({
            fulfilled: r,
            rejected: o,
            synchronous: a ? a.synchronous : !1,
            runWhen: a ? a.runWhen : null
        }), this.handlers.length - 1
    }
    eject(r) {
        this.handlers[r] && (this.handlers[r] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(r) {
        L.forEach(this.handlers, function(a) {
            a !== null && r(a)
        })
    }
}
const Bi = {
        silentJSONParsing: !0,
        forcedJSONParsing: !0,
        clarifyTimeoutError: !1
    },
    Th = typeof URLSearchParams < "u" ? URLSearchParams : ia,
    Ch = typeof FormData < "u" ? FormData : null,
    Ah = typeof Blob < "u" ? Blob : null,
    Ih = {
        isBrowser: !0,
        classes: {
            URLSearchParams: Th,
            FormData: Ch,
            Blob: Ah
        },
        protocols: ["http", "https", "file", "blob", "url", "data"]
    },
    ua = typeof window < "u" && typeof document < "u",
    Nh = (t => ua && ["ReactNative", "NativeScript", "NS"].indexOf(t) < 0)(typeof navigator < "u" && navigator.product),
    Lh = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function",
    Fh = ua && window.location.href || "http://localhost",
    Dh = Object.freeze(Object.defineProperty({
        __proto__: null,
        hasBrowserEnv: ua,
        hasStandardBrowserEnv: Nh,
        hasStandardBrowserWebWorkerEnv: Lh,
        origin: Fh
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    yt = { ...Dh,
        ...Ih
    };

function Mh(t, r) {
    return jr(t, new yt.classes.URLSearchParams, Object.assign({
        visitor: function(o, a, c, i) {
            return yt.isNode && L.isBuffer(o) ? (this.append(a, o.toString("base64")), !1) : i.defaultVisitor.apply(this, arguments)
        }
    }, r))
}

function jh(t) {
    return L.matchAll(/\w+|\[(\w*)]/g, t).map(r => r[0] === "[]" ? "" : r[1] || r[0])
}

function Bh(t) {
    const r = {},
        o = Object.keys(t);
    let a;
    const c = o.length;
    let i;
    for (a = 0; a < c; a++) i = o[a], r[i] = t[i];
    return r
}

function Ki(t) {
    function r(o, a, c, i) {
        let f = o[i++];
        if (f === "__proto__") return !0;
        const p = Number.isFinite(+f),
            m = i >= o.length;
        return f = !f && L.isArray(c) ? c.length : f, m ? (L.hasOwnProp(c, f) ? c[f] = [c[f], a] : c[f] = a, !p) : ((!c[f] || !L.isObject(c[f])) && (c[f] = []), r(o, a, c[f], i) && L.isArray(c[f]) && (c[f] = Bh(c[f])), !p)
    }
    if (L.isFormData(t) && L.isFunction(t.entries)) {
        const o = {};
        return L.forEachEntry(t, (a, c) => {
            r(jh(a), c, o, 0)
        }), o
    }
    return null
}

function Kh(t, r, o) {
    if (L.isString(t)) try {
        return (r || JSON.parse)(t), L.trim(t)
    } catch (a) {
        if (a.name !== "SyntaxError") throw a
    }
    return (o || JSON.stringify)(t)
}
const zn = {
    transitional: Bi,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function(r, o) {
        const a = o.getContentType() || "",
            c = a.indexOf("application/json") > -1,
            i = L.isObject(r);
        if (i && L.isHTMLForm(r) && (r = new FormData(r)), L.isFormData(r)) return c ? JSON.stringify(Ki(r)) : r;
        if (L.isArrayBuffer(r) || L.isBuffer(r) || L.isStream(r) || L.isFile(r) || L.isBlob(r) || L.isReadableStream(r)) return r;
        if (L.isArrayBufferView(r)) return r.buffer;
        if (L.isURLSearchParams(r)) return o.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), r.toString();
        let p;
        if (i) {
            if (a.indexOf("application/x-www-form-urlencoded") > -1) return Mh(r, this.formSerializer).toString();
            if ((p = L.isFileList(r)) || a.indexOf("multipart/form-data") > -1) {
                const m = this.env && this.env.FormData;
                return jr(p ? {
                    "files[]": r
                } : r, m && new m, this.formSerializer)
            }
        }
        return i || c ? (o.setContentType("application/json", !1), Kh(r)) : r
    }],
    transformResponse: [function(r) {
        const o = this.transitional || zn.transitional,
            a = o && o.forcedJSONParsing,
            c = this.responseType === "json";
        if (L.isResponse(r) || L.isReadableStream(r)) return r;
        if (r && L.isString(r) && (a && !this.responseType || c)) {
            const f = !(o && o.silentJSONParsing) && c;
            try {
                return JSON.parse(r)
            } catch (p) {
                if (f) throw p.name === "SyntaxError" ? le.from(p, le.ERR_BAD_RESPONSE, this, null, this.response) : p
            }
        }
        return r
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: yt.classes.FormData,
        Blob: yt.classes.Blob
    },
    validateStatus: function(r) {
        return r >= 200 && r < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
L.forEach(["delete", "get", "head", "post", "put", "patch"], t => {
    zn.headers[t] = {}
});
const Uh = L.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]),
    qh = t => {
        const r = {};
        let o, a, c;
        return t && t.split("\n").forEach(function(f) {
            c = f.indexOf(":"), o = f.substring(0, c).trim().toLowerCase(), a = f.substring(c + 1).trim(), !(!o || r[o] && Uh[o]) && (o === "set-cookie" ? r[o] ? r[o].push(a) : r[o] = [a] : r[o] = r[o] ? r[o] + ", " + a : a)
        }), r
    },
    Ns = Symbol("internals");

function Mn(t) {
    return t && String(t).trim().toLowerCase()
}

function Rr(t) {
    return t === !1 || t == null ? t : L.isArray(t) ? t.map(Rr) : String(t)
}

function Vh(t) {
    const r = Object.create(null),
        o = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let a;
    for (; a = o.exec(t);) r[a[1]] = a[2];
    return r
}
const Hh = t => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());

function ko(t, r, o, a, c) {
    if (L.isFunction(a)) return a.call(this, r, o);
    if (c && (r = o), !!L.isString(r)) {
        if (L.isString(a)) return r.indexOf(a) !== -1;
        if (L.isRegExp(a)) return a.test(r)
    }
}

function $h(t) {
    return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (r, o, a) => o.toUpperCase() + a)
}

function Wh(t, r) {
    const o = L.toCamelCase(" " + r);
    ["get", "set", "has"].forEach(a => {
        Object.defineProperty(t, a + o, {
            value: function(c, i, f) {
                return this[a].call(this, r, c, i, f)
            },
            configurable: !0
        })
    })
}
let nt = class {
    constructor(r) {
        r && this.set(r)
    }
    set(r, o, a) {
        const c = this;

        function i(p, m, v) {
            const g = Mn(m);
            if (!g) throw new Error("header name must be a non-empty string");
            const _ = L.findKey(c, g);
            (!_ || c[_] === void 0 || v === !0 || v === void 0 && c[_] !== !1) && (c[_ || m] = Rr(p))
        }
        const f = (p, m) => L.forEach(p, (v, g) => i(v, g, m));
        if (L.isPlainObject(r) || r instanceof this.constructor) f(r, o);
        else if (L.isString(r) && (r = r.trim()) && !Hh(r)) f(qh(r), o);
        else if (L.isHeaders(r))
            for (const [p, m] of r.entries()) i(m, p, a);
        else r != null && i(o, r, a);
        return this
    }
    get(r, o) {
        if (r = Mn(r), r) {
            const a = L.findKey(this, r);
            if (a) {
                const c = this[a];
                if (!o) return c;
                if (o === !0) return Vh(c);
                if (L.isFunction(o)) return o.call(this, c, a);
                if (L.isRegExp(o)) return o.exec(c);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(r, o) {
        if (r = Mn(r), r) {
            const a = L.findKey(this, r);
            return !!(a && this[a] !== void 0 && (!o || ko(this, this[a], a, o)))
        }
        return !1
    }
    delete(r, o) {
        const a = this;
        let c = !1;

        function i(f) {
            if (f = Mn(f), f) {
                const p = L.findKey(a, f);
                p && (!o || ko(a, a[p], p, o)) && (delete a[p], c = !0)
            }
        }
        return L.isArray(r) ? r.forEach(i) : i(r), c
    }
    clear(r) {
        const o = Object.keys(this);
        let a = o.length,
            c = !1;
        for (; a--;) {
            const i = o[a];
            (!r || ko(this, this[i], i, r, !0)) && (delete this[i], c = !0)
        }
        return c
    }
    normalize(r) {
        const o = this,
            a = {};
        return L.forEach(this, (c, i) => {
            const f = L.findKey(a, i);
            if (f) {
                o[f] = Rr(c), delete o[i];
                return
            }
            const p = r ? $h(i) : String(i).trim();
            p !== i && delete o[i], o[p] = Rr(c), a[p] = !0
        }), this
    }
    concat(...r) {
        return this.constructor.concat(this, ...r)
    }
    toJSON(r) {
        const o = Object.create(null);
        return L.forEach(this, (a, c) => {
            a != null && a !== !1 && (o[c] = r && L.isArray(a) ? a.join(", ") : a)
        }), o
    }[Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map(([r, o]) => r + ": " + o).join("\n")
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(r) {
        return r instanceof this ? r : new this(r)
    }
    static concat(r, ...o) {
        const a = new this(r);
        return o.forEach(c => a.set(c)), a
    }
    static accessor(r) {
        const a = (this[Ns] = this[Ns] = {
                accessors: {}
            }).accessors,
            c = this.prototype;

        function i(f) {
            const p = Mn(f);
            a[p] || (Wh(c, f), a[p] = !0)
        }
        return L.isArray(r) ? r.forEach(i) : i(r), this
    }
};
nt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
L.reduceDescriptors(nt.prototype, ({
    value: t
}, r) => {
    let o = r[0].toUpperCase() + r.slice(1);
    return {
        get: () => t,
        set(a) {
            this[o] = a
        }
    }
});
L.freezeMethods(nt);

function Po(t, r) {
    const o = this || zn,
        a = r || o,
        c = nt.from(a.headers);
    let i = a.data;
    return L.forEach(t, function(p) {
        i = p.call(o, i, c.normalize(), r ? r.status : void 0)
    }), c.normalize(), i
}

function Ui(t) {
    return !!(t && t.__CANCEL__)
}

function En(t, r, o) {
    le.call(this, t == null ? "canceled" : t, le.ERR_CANCELED, r, o), this.name = "CanceledError"
}
L.inherits(En, le, {
    __CANCEL__: !0
});

function qi(t, r, o) {
    const a = o.config.validateStatus;
    !o.status || !a || a(o.status) ? t(o) : r(new le("Request failed with status code " + o.status, [le.ERR_BAD_REQUEST, le.ERR_BAD_RESPONSE][Math.floor(o.status / 100) - 4], o.config, o.request, o))
}

function zh(t) {
    const r = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
    return r && r[1] || ""
}

function Gh(t, r) {
    t = t || 10;
    const o = new Array(t),
        a = new Array(t);
    let c = 0,
        i = 0,
        f;
    return r = r !== void 0 ? r : 1e3,
        function(m) {
            const v = Date.now(),
                g = a[i];
            f || (f = v), o[c] = m, a[c] = v;
            let _ = i,
                T = 0;
            for (; _ !== c;) T += o[_++], _ = _ % t;
            if (c = (c + 1) % t, c === i && (i = (i + 1) % t), v - f < r) return;
            const A = g && v - g;
            return A ? Math.round(T * 1e3 / A) : void 0
        }
}

function Yh(t, r) {
    let o = 0;
    const a = 1e3 / r;
    let c = null;
    return function() {
        const f = this === !0,
            p = Date.now();
        if (f || p - o > a) return c && (clearTimeout(c), c = null), o = p, t.apply(null, arguments);
        c || (c = setTimeout(() => (c = null, o = Date.now(), t.apply(null, arguments)), a - (p - o)))
    }
}
const kr = (t, r, o = 3) => {
        let a = 0;
        const c = Gh(50, 250);
        return Yh(i => {
            const f = i.loaded,
                p = i.lengthComputable ? i.total : void 0,
                m = f - a,
                v = c(m),
                g = f <= p;
            a = f;
            const _ = {
                loaded: f,
                total: p,
                progress: p ? f / p : void 0,
                bytes: m,
                rate: v || void 0,
                estimated: v && p && g ? (p - f) / v : void 0,
                event: i,
                lengthComputable: p != null
            };
            _[r ? "download" : "upload"] = !0, t(_)
        }, o)
    },
    Jh = yt.hasStandardBrowserEnv ? function() {
        const r = /(msie|trident)/i.test(navigator.userAgent),
            o = document.createElement("a");
        let a;

        function c(i) {
            let f = i;
            return r && (o.setAttribute("href", f), f = o.href), o.setAttribute("href", f), {
                href: o.href,
                protocol: o.protocol ? o.protocol.replace(/:$/, "") : "",
                host: o.host,
                search: o.search ? o.search.replace(/^\?/, "") : "",
                hash: o.hash ? o.hash.replace(/^#/, "") : "",
                hostname: o.hostname,
                port: o.port,
                pathname: o.pathname.charAt(0) === "/" ? o.pathname : "/" + o.pathname
            }
        }
        return a = c(window.location.href),
            function(f) {
                const p = L.isString(f) ? c(f) : f;
                return p.protocol === a.protocol && p.host === a.host
            }
    }() : function() {
        return function() {
            return !0
        }
    }(),
    Xh = yt.hasStandardBrowserEnv ? {
        write(t, r, o, a, c, i) {
            const f = [t + "=" + encodeURIComponent(r)];
            L.isNumber(o) && f.push("expires=" + new Date(o).toGMTString()), L.isString(a) && f.push("path=" + a), L.isString(c) && f.push("domain=" + c), i === !0 && f.push("secure"), document.cookie = f.join("; ")
        },
        read(t) {
            const r = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
            return r ? decodeURIComponent(r[3]) : null
        },
        remove(t) {
            this.write(t, "", Date.now() - 864e5)
        }
    } : {
        write() {},
        read() {
            return null
        },
        remove() {}
    };

function Qh(t) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t)
}

function Zh(t, r) {
    return r ? t.replace(/\/?\/$/, "") + "/" + r.replace(/^\/+/, "") : t
}

function Vi(t, r) {
    return t && !Qh(r) ? Zh(t, r) : r
}
const Ls = t => t instanceof nt ? { ...t
} : t;

function tn(t, r) {
    r = r || {};
    const o = {};

    function a(v, g, _) {
        return L.isPlainObject(v) && L.isPlainObject(g) ? L.merge.call({
            caseless: _
        }, v, g) : L.isPlainObject(g) ? L.merge({}, g) : L.isArray(g) ? g.slice() : g
    }

    function c(v, g, _) {
        if (L.isUndefined(g)) {
            if (!L.isUndefined(v)) return a(void 0, v, _)
        } else return a(v, g, _)
    }

    function i(v, g) {
        if (!L.isUndefined(g)) return a(void 0, g)
    }

    function f(v, g) {
        if (L.isUndefined(g)) {
            if (!L.isUndefined(v)) return a(void 0, v)
        } else return a(void 0, g)
    }

    function p(v, g, _) {
        if (_ in r) return a(v, g);
        if (_ in t) return a(void 0, v)
    }
    const m = {
        url: i,
        method: i,
        data: i,
        baseURL: f,
        transformRequest: f,
        transformResponse: f,
        paramsSerializer: f,
        timeout: f,
        timeoutMessage: f,
        withCredentials: f,
        withXSRFToken: f,
        adapter: f,
        responseType: f,
        xsrfCookieName: f,
        xsrfHeaderName: f,
        onUploadProgress: f,
        onDownloadProgress: f,
        decompress: f,
        maxContentLength: f,
        maxBodyLength: f,
        beforeRedirect: f,
        transport: f,
        httpAgent: f,
        httpsAgent: f,
        cancelToken: f,
        socketPath: f,
        responseEncoding: f,
        validateStatus: p,
        headers: (v, g) => c(Ls(v), Ls(g), !0)
    };
    return L.forEach(Object.keys(Object.assign({}, t, r)), function(g) {
        const _ = m[g] || c,
            T = _(t[g], r[g], g);
        L.isUndefined(T) && _ !== p || (o[g] = T)
    }), o
}
const Hi = t => {
        const r = tn({}, t);
        let {
            data: o,
            withXSRFToken: a,
            xsrfHeaderName: c,
            xsrfCookieName: i,
            headers: f,
            auth: p
        } = r;
        r.headers = f = nt.from(f), r.url = ji(Vi(r.baseURL, r.url), t.params, t.paramsSerializer), p && f.set("Authorization", "Basic " + btoa((p.username || "") + ":" + (p.password ? unescape(encodeURIComponent(p.password)) : "")));
        let m;
        if (L.isFormData(o)) {
            if (yt.hasStandardBrowserEnv || yt.hasStandardBrowserWebWorkerEnv) f.setContentType(void 0);
            else if ((m = f.getContentType()) !== !1) {
                const [v, ...g] = m ? m.split(";").map(_ => _.trim()).filter(Boolean) : [];
                f.setContentType([v || "multipart/form-data", ...g].join("; "))
            }
        }
        if (yt.hasStandardBrowserEnv && (a && L.isFunction(a) && (a = a(r)), a || a !== !1 && Jh(r.url))) {
            const v = c && i && Xh.read(i);
            v && f.set(c, v)
        }
        return r
    },
    ep = typeof XMLHttpRequest < "u",
    tp = ep && function(t) {
        return new Promise(function(o, a) {
            const c = Hi(t);
            let i = c.data;
            const f = nt.from(c.headers).normalize();
            let {
                responseType: p
            } = c, m;

            function v() {
                c.cancelToken && c.cancelToken.unsubscribe(m), c.signal && c.signal.removeEventListener("abort", m)
            }
            let g = new XMLHttpRequest;
            g.open(c.method.toUpperCase(), c.url, !0), g.timeout = c.timeout;

            function _() {
                if (!g) return;
                const A = nt.from("getAllResponseHeaders" in g && g.getAllResponseHeaders()),
                    q = {
                        data: !p || p === "text" || p === "json" ? g.responseText : g.response,
                        status: g.status,
                        statusText: g.statusText,
                        headers: A,
                        config: t,
                        request: g
                    };
                qi(function(oe) {
                    o(oe), v()
                }, function(oe) {
                    a(oe), v()
                }, q), g = null
            }
            "onloadend" in g ? g.onloadend = _ : g.onreadystatechange = function() {
                !g || g.readyState !== 4 || g.status === 0 && !(g.responseURL && g.responseURL.indexOf("file:") === 0) || setTimeout(_)
            }, g.onabort = function() {
                g && (a(new le("Request aborted", le.ECONNABORTED, c, g)), g = null)
            }, g.onerror = function() {
                a(new le("Network Error", le.ERR_NETWORK, c, g)), g = null
            }, g.ontimeout = function() {
                let B = c.timeout ? "timeout of " + c.timeout + "ms exceeded" : "timeout exceeded";
                const q = c.transitional || Bi;
                c.timeoutErrorMessage && (B = c.timeoutErrorMessage), a(new le(B, q.clarifyTimeoutError ? le.ETIMEDOUT : le.ECONNABORTED, c, g)), g = null
            }, i === void 0 && f.setContentType(null), "setRequestHeader" in g && L.forEach(f.toJSON(), function(B, q) {
                g.setRequestHeader(q, B)
            }), L.isUndefined(c.withCredentials) || (g.withCredentials = !!c.withCredentials), p && p !== "json" && (g.responseType = c.responseType), typeof c.onDownloadProgress == "function" && g.addEventListener("progress", kr(c.onDownloadProgress, !0)), typeof c.onUploadProgress == "function" && g.upload && g.upload.addEventListener("progress", kr(c.onUploadProgress)), (c.cancelToken || c.signal) && (m = A => {
                g && (a(!A || A.type ? new En(null, t, g) : A), g.abort(), g = null)
            }, c.cancelToken && c.cancelToken.subscribe(m), c.signal && (c.signal.aborted ? m() : c.signal.addEventListener("abort", m)));
            const T = zh(c.url);
            if (T && yt.protocols.indexOf(T) === -1) {
                a(new le("Unsupported protocol " + T + ":", le.ERR_BAD_REQUEST, t));
                return
            }
            g.send(i || null)
        })
    },
    np = (t, r) => {
        let o = new AbortController,
            a;
        const c = function(m) {
            if (!a) {
                a = !0, f();
                const v = m instanceof Error ? m : this.reason;
                o.abort(v instanceof le ? v : new En(v instanceof Error ? v.message : v))
            }
        };
        let i = r && setTimeout(() => {
            c(new le("timeout ".concat(r, " of ms exceeded"), le.ETIMEDOUT))
        }, r);
        const f = () => {
            t && (i && clearTimeout(i), i = null, t.forEach(m => {
                m && (m.removeEventListener ? m.removeEventListener("abort", c) : m.unsubscribe(c))
            }), t = null)
        };
        t.forEach(m => m && m.addEventListener && m.addEventListener("abort", c));
        const {
            signal: p
        } = o;
        return p.unsubscribe = f, [p, () => {
            i && clearTimeout(i), i = null
        }]
    },
    rp = function*(t, r) {
        let o = t.byteLength;
        if (!r || o < r) {
            yield t;
            return
        }
        let a = 0,
            c;
        for (; a < o;) c = a + r, yield t.slice(a, c), a = c
    },
    op = async function*(t, r, o) {
        for await (const a of t) yield* rp(ArrayBuffer.isView(a) ? a : await o(String(a)), r)
    },
    Fs = (t, r, o, a, c) => {
        const i = op(t, r, c);
        let f = 0;
        return new ReadableStream({
            type: "bytes",
            async pull(p) {
                const {
                    done: m,
                    value: v
                } = await i.next();
                if (m) {
                    p.close(), a();
                    return
                }
                let g = v.byteLength;
                o && o(f += g), p.enqueue(new Uint8Array(v))
            },
            cancel(p) {
                return a(p), i.return()
            }
        }, {
            highWaterMark: 2
        })
    },
    Ds = (t, r) => {
        const o = t != null;
        return a => setTimeout(() => r({
            lengthComputable: o,
            total: t,
            loaded: a
        }))
    },
    Br = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function",
    $i = Br && typeof ReadableStream == "function",
    Vo = Br && (typeof TextEncoder == "function" ? (t => r => t.encode(r))(new TextEncoder) : async t => new Uint8Array(await new Response(t).arrayBuffer())),
    ap = $i && (() => {
        let t = !1;
        const r = new Request(yt.origin, {
            body: new ReadableStream,
            method: "POST",
            get duplex() {
                return t = !0, "half"
            }
        }).headers.has("Content-Type");
        return t && !r
    })(),
    Ms = 64 * 1024,
    Ho = $i && !!(() => {
        try {
            return L.isReadableStream(new Response("").body)
        } catch (t) {}
    })(),
    Pr = {
        stream: Ho && (t => t.body)
    };
Br && (t => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(r => {
        !Pr[r] && (Pr[r] = L.isFunction(t[r]) ? o => o[r]() : (o, a) => {
            throw new le("Response type '".concat(r, "' is not supported"), le.ERR_NOT_SUPPORT, a)
        })
    })
})(new Response);
const sp = async t => {
        if (t == null) return 0;
        if (L.isBlob(t)) return t.size;
        if (L.isSpecCompliantForm(t)) return (await new Request(t).arrayBuffer()).byteLength;
        if (L.isArrayBufferView(t)) return t.byteLength;
        if (L.isURLSearchParams(t) && (t = t + ""), L.isString(t)) return (await Vo(t)).byteLength
    },
    ip = async (t, r) => {
        const o = L.toFiniteNumber(t.getContentLength());
        return o == null ? sp(r) : o
    },
    up = Br && (async t => {
        let {
            url: r,
            method: o,
            data: a,
            signal: c,
            cancelToken: i,
            timeout: f,
            onDownloadProgress: p,
            onUploadProgress: m,
            responseType: v,
            headers: g,
            withCredentials: _ = "same-origin",
            fetchOptions: T
        } = Hi(t);
        v = v ? (v + "").toLowerCase() : "text";
        let [A, B] = c || i || f ? np([c, i], f) : [], q, re;
        const oe = () => {
            !q && setTimeout(() => {
                A && A.unsubscribe()
            }), q = !0
        };
        let te;
        try {
            if (m && ap && o !== "get" && o !== "head" && (te = await ip(g, a)) !== 0) {
                let me = new Request(r, {
                        method: "POST",
                        body: a,
                        duplex: "half"
                    }),
                    se;
                L.isFormData(a) && (se = me.headers.get("content-type")) && g.setContentType(se), me.body && (a = Fs(me.body, Ms, Ds(te, kr(m)), null, Vo))
            }
            L.isString(_) || (_ = _ ? "cors" : "omit"), re = new Request(r, { ...T,
                signal: A,
                method: o.toUpperCase(),
                headers: g.normalize().toJSON(),
                body: a,
                duplex: "half",
                withCredentials: _
            });
            let Q = await fetch(re);
            const ye = Ho && (v === "stream" || v === "response");
            if (Ho && (p || ye)) {
                const me = {};
                ["status", "statusText", "headers"].forEach(fe => {
                    me[fe] = Q[fe]
                });
                const se = L.toFiniteNumber(Q.headers.get("content-length"));
                Q = new Response(Fs(Q.body, Ms, p && Ds(se, kr(p, !0)), ye && oe, Vo), me)
            }
            v = v || "text";
            let _e = await Pr[L.findKey(Pr, v) || "text"](Q, t);
            return !ye && oe(), B && B(), await new Promise((me, se) => {
                qi(me, se, {
                    data: _e,
                    headers: nt.from(Q.headers),
                    status: Q.status,
                    statusText: Q.statusText,
                    config: t,
                    request: re
                })
            })
        } catch (Q) {
            throw oe(), Q && Q.name === "TypeError" && /fetch/i.test(Q.message) ? Object.assign(new le("Network Error", le.ERR_NETWORK, t, re), {
                cause: Q.cause || Q
            }) : le.from(Q, Q && Q.code, t, re)
        }
    }),
    $o = {
        http: Sh,
        xhr: tp,
        fetch: up
    };
L.forEach($o, (t, r) => {
    if (t) {
        try {
            Object.defineProperty(t, "name", {
                value: r
            })
        } catch (o) {}
        Object.defineProperty(t, "adapterName", {
            value: r
        })
    }
});
const js = t => "- ".concat(t),
    cp = t => L.isFunction(t) || t === null || t === !1,
    Wi = {
        getAdapter: t => {
            t = L.isArray(t) ? t : [t];
            const {
                length: r
            } = t;
            let o, a;
            const c = {};
            for (let i = 0; i < r; i++) {
                o = t[i];
                let f;
                if (a = o, !cp(o) && (a = $o[(f = String(o)).toLowerCase()], a === void 0)) throw new le("Unknown adapter '".concat(f, "'"));
                if (a) break;
                c[f || "#" + i] = a
            }
            if (!a) {
                const i = Object.entries(c).map(([p, m]) => "adapter ".concat(p, " ") + (m === !1 ? "is not supported by the environment" : "is not available in the build"));
                let f = r ? i.length > 1 ? "since :\n" + i.map(js).join("\n") : " " + js(i[0]) : "as no adapter specified";
                throw new le("There is no suitable adapter to dispatch the request " + f, "ERR_NOT_SUPPORT")
            }
            return a
        },
        adapters: $o
    };

function xo(t) {
    if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted) throw new En(null, t)
}

function Bs(t) {
    return xo(t), t.headers = nt.from(t.headers), t.data = Po.call(t, t.transformRequest), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), Wi.getAdapter(t.adapter || zn.adapter)(t).then(function(a) {
        return xo(t), a.data = Po.call(t, t.transformResponse, a), a.headers = nt.from(a.headers), a
    }, function(a) {
        return Ui(a) || (xo(t), a && a.response && (a.response.data = Po.call(t, t.transformResponse, a.response), a.response.headers = nt.from(a.response.headers))), Promise.reject(a)
    })
}
const zi = "1.7.2",
    ca = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, r) => {
    ca[t] = function(a) {
        return typeof a === t || "a" + (r < 1 ? "n " : " ") + t
    }
});
const Ks = {};
ca.transitional = function(r, o, a) {
    function c(i, f) {
        return "[Axios v" + zi + "] Transitional option '" + i + "'" + f + (a ? ". " + a : "")
    }
    return (i, f, p) => {
        if (r === !1) throw new le(c(f, " has been removed" + (o ? " in " + o : "")), le.ERR_DEPRECATED);
        return o && !Ks[f] && (Ks[f] = !0, console.warn(c(f, " has been deprecated since v" + o + " and will be removed in the near future"))), r ? r(i, f, p) : !0
    }
};

function lp(t, r, o) {
    if (typeof t != "object") throw new le("options must be an object", le.ERR_BAD_OPTION_VALUE);
    const a = Object.keys(t);
    let c = a.length;
    for (; c-- > 0;) {
        const i = a[c],
            f = r[i];
        if (f) {
            const p = t[i],
                m = p === void 0 || f(p, i, t);
            if (m !== !0) throw new le("option " + i + " must be " + m, le.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (o !== !0) throw new le("Unknown option " + i, le.ERR_BAD_OPTION)
    }
}
const Wo = {
        assertOptions: lp,
        validators: ca
    },
    Kt = Wo.validators;
let Zt = class {
    constructor(r) {
        this.defaults = r, this.interceptors = {
            request: new Is,
            response: new Is
        }
    }
    async request(r, o) {
        try {
            return await this._request(r, o)
        } catch (a) {
            if (a instanceof Error) {
                let c;
                Error.captureStackTrace ? Error.captureStackTrace(c = {}) : c = new Error;
                const i = c.stack ? c.stack.replace(/^.+\n/, "") : "";
                try {
                    a.stack ? i && !String(a.stack).endsWith(i.replace(/^.+\n.+\n/, "")) && (a.stack += "\n" + i) : a.stack = i
                } catch (f) {}
            }
            throw a
        }
    }
    _request(r, o) {
        typeof r == "string" ? (o = o || {}, o.url = r) : o = r || {}, o = tn(this.defaults, o);
        const {
            transitional: a,
            paramsSerializer: c,
            headers: i
        } = o;
        a !== void 0 && Wo.assertOptions(a, {
            silentJSONParsing: Kt.transitional(Kt.boolean),
            forcedJSONParsing: Kt.transitional(Kt.boolean),
            clarifyTimeoutError: Kt.transitional(Kt.boolean)
        }, !1), c != null && (L.isFunction(c) ? o.paramsSerializer = {
            serialize: c
        } : Wo.assertOptions(c, {
            encode: Kt.function,
            serialize: Kt.function
        }, !0)), o.method = (o.method || this.defaults.method || "get").toLowerCase();
        let f = i && L.merge(i.common, i[o.method]);
        i && L.forEach(["delete", "get", "head", "post", "put", "patch", "common"], B => {
            delete i[B]
        }), o.headers = nt.concat(f, i);
        const p = [];
        let m = !0;
        this.interceptors.request.forEach(function(q) {
            typeof q.runWhen == "function" && q.runWhen(o) === !1 || (m = m && q.synchronous, p.unshift(q.fulfilled, q.rejected))
        });
        const v = [];
        this.interceptors.response.forEach(function(q) {
            v.push(q.fulfilled, q.rejected)
        });
        let g, _ = 0,
            T;
        if (!m) {
            const B = [Bs.bind(this), void 0];
            for (B.unshift.apply(B, p), B.push.apply(B, v), T = B.length, g = Promise.resolve(o); _ < T;) g = g.then(B[_++], B[_++]);
            return g
        }
        T = p.length;
        let A = o;
        for (_ = 0; _ < T;) {
            const B = p[_++],
                q = p[_++];
            try {
                A = B(A)
            } catch (re) {
                q.call(this, re);
                break
            }
        }
        try {
            g = Bs.call(this, A)
        } catch (B) {
            return Promise.reject(B)
        }
        for (_ = 0, T = v.length; _ < T;) g = g.then(v[_++], v[_++]);
        return g
    }
    getUri(r) {
        r = tn(this.defaults, r);
        const o = Vi(r.baseURL, r.url);
        return ji(o, r.params, r.paramsSerializer)
    }
};
L.forEach(["delete", "get", "head", "options"], function(r) {
    Zt.prototype[r] = function(o, a) {
        return this.request(tn(a || {}, {
            method: r,
            url: o,
            data: (a || {}).data
        }))
    }
});
L.forEach(["post", "put", "patch"], function(r) {
    function o(a) {
        return function(i, f, p) {
            return this.request(tn(p || {}, {
                method: r,
                headers: a ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: i,
                data: f
            }))
        }
    }
    Zt.prototype[r] = o(), Zt.prototype[r + "Form"] = o(!0)
});
let fp = class Gi {
    constructor(r) {
        if (typeof r != "function") throw new TypeError("executor must be a function.");
        let o;
        this.promise = new Promise(function(i) {
            o = i
        });
        const a = this;
        this.promise.then(c => {
            if (!a._listeners) return;
            let i = a._listeners.length;
            for (; i-- > 0;) a._listeners[i](c);
            a._listeners = null
        }), this.promise.then = c => {
            let i;
            const f = new Promise(p => {
                a.subscribe(p), i = p
            }).then(c);
            return f.cancel = function() {
                a.unsubscribe(i)
            }, f
        }, r(function(i, f, p) {
            a.reason || (a.reason = new En(i, f, p), o(a.reason))
        })
    }
    throwIfRequested() {
        if (this.reason) throw this.reason
    }
    subscribe(r) {
        if (this.reason) {
            r(this.reason);
            return
        }
        this._listeners ? this._listeners.push(r) : this._listeners = [r]
    }
    unsubscribe(r) {
        if (!this._listeners) return;
        const o = this._listeners.indexOf(r);
        o !== -1 && this._listeners.splice(o, 1)
    }
    static source() {
        let r;
        return {
            token: new Gi(function(c) {
                r = c
            }),
            cancel: r
        }
    }
};

function dp(t) {
    return function(o) {
        return t.apply(null, o)
    }
}

function hp(t) {
    return L.isObject(t) && t.isAxiosError === !0
}
const zo = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(zo).forEach(([t, r]) => {
    zo[r] = t
});

function Yi(t) {
    const r = new Zt(t),
        o = ki(Zt.prototype.request, r);
    return L.extend(o, Zt.prototype, r, {
        allOwnKeys: !0
    }), L.extend(o, r, null, {
        allOwnKeys: !0
    }), o.create = function(c) {
        return Yi(tn(t, c))
    }, o
}
const De = Yi(zn);
De.Axios = Zt;
De.CanceledError = En;
De.CancelToken = fp;
De.isCancel = Ui;
De.VERSION = zi;
De.toFormData = jr;
De.AxiosError = le;
De.Cancel = De.CanceledError;
De.all = function(r) {
    return Promise.all(r)
};
De.spread = dp;
De.isAxiosError = hp;
De.mergeConfig = tn;
De.AxiosHeaders = nt;
De.formToJSON = t => Ki(L.isHTMLForm(t) ? new FormData(t) : t);
De.getAdapter = Wi.getAdapter;
De.HttpStatusCode = zo;
De.default = De;
const {
    Axios: Ap,
    AxiosError: Ip,
    CanceledError: Np,
    isCancel: Lp,
    CancelToken: Fp,
    VERSION: Dp,
    all: Mp,
    Cancel: jp,
    isAxiosError: Bp,
    spread: Kp,
    toFormData: Up,
    AxiosHeaders: qp,
    HttpStatusCode: Vp,
    formToJSON: Hp,
    getAdapter: $p,
    mergeConfig: Wp
} = De;
export {
    Ip as A, Za as D, bp as I, Bd as R, Fo as T, vp as _, Pp as a, ra as b, _p as c, Ep as d, De as e, qi as f, L as g, Vi as h, ji as i, kp as j, Op as k, wp as l, Sp as o, Rp as s, xp as u
};
//# sourceMappingURL=vendor-stable.Cg92BvZJ.js.map